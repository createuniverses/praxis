#include "IoState.h"
#include "IoObject.h"

void IoVMCodeInit(IoObject *context)
{
	IoState *self = IoObject_state((IoObject *)context);
	char *s;

	s = "Object do(\n"
  	"  /*doc Object inlineMethod\n"
  	"  Creates a method which is executed directly in a receiver (no Locals object is created).\n"
  	"  <br/>\n"
  	"  <pre>\n"
  	"  Io> m := inlineMethod(x := x*2)\n"
  	"  Io> x := 1\n"
  	"  ==> 1\n"
  	"  Io> m\n"
  	"  ==> 2\n"
  	"  Io> m\n"
  	"  ==> 4\n"
  	"  Io> m\n"
  	"  ==> 8\n"
  	"  </pre>\n"
  	"  */\n"
  	"    inlineMethod := method(call message argAt(0) setIsActivatable(true))\n"
  	")\n"
  	"\n"
  	"List do(\n"
  	"    /*doc List selectInPlace(optionalIndex, value, message)\n"
  	"    Like foreach, but the values for which the result of message is either nil\n"
  	"    or false are removed from the List. Example:\n"
  	"<pre>list(1, 5, 7, 2) selectInPlace(i, v, v > 3)\n"
  	"==> 5, 7\n"
  	"list(1, 5, 7, 2) selectInPlace(v, v > 3)\n"
  	" ==> 5, 7</pre>\n"
  	"*/\n"
  	"    selectInPlace := method(\n"
  	"        # Creating a context, in which the body would be executed in.\n"
  	"        context := Object clone prependProto(call sender)\n"
  	"        # Note: this is needed for the Object_forwardLocals() method to\n"
  	"        # work correctly. See IoObject.c:870.\n"
  	"        if(call sender hasLocalSlot(\"self\"),\n"
  	"            context setSlot(\"self\", call sender self)\n"
  	"        )\n"
  	"        # Offset, applied to get the real index of the elements being\n"
  	"        # deleted.\n"
  	"        offset := 0\n"
  	"        argCount := call argCount\n"
  	"\n"
  	"        if(argCount == 0, Exception raise(\"missing argument\"))\n"
  	"        if(argCount == 1) then(\n"
  	"            body := call argAt(0)\n"
  	"            size repeat(idx,\n"
  	"                if(at(idx - offset) doMessage(body, context) not,\n"
  	"                    removeAt(idx - offset)\n"
  	"                    offset = offset + 1\n"
  	"                )\n"
  	"            )\n"
  	"        ) elseif(argCount == 2) then(\n"
  	"            eName := call argAt(0) name # Element.\n"
  	"            body  := call argAt(1)\n"
  	"            size repeat(idx,\n"
  	"                context setSlot(eName, at(idx - offset))\n"
  	"                if(context doMessage(body) not,\n"
  	"                    removeAt(idx - offset)\n"
  	"                    offset = offset + 1\n"
  	"                )\n"
  	"            )\n"
  	"        ) else(\n"
  	"            iName := call argAt(0) name # Index.\n"
  	"            eName := call argAt(1) name # Element.\n"
  	"            body  := call argAt(2)\n"
  	"\n"
  	"            size repeat(idx,\n"
  	"                context setSlot(iName, idx)\n"
  	"                context setSlot(eName, at(idx - offset))\n"
  	"                if(context doMessage(body) not,\n"
  	"                    removeAt(idx - offset)\n"
  	"                    offset = offset + 1\n"
  	"                )\n"
  	"            )\n"
  	"        )\n"
  	"        self\n"
  	"    )\n"
  	"\n"
  	"    //doc List select Same as <tt>selectInPlace</tt>, but result is a new List.\n"
  	"    select := method(\n"
  	"        call delegateToMethod(self clone, \"selectInPlace\")\n"
  	"    )\n"
  	"\n"
  	"    /*doc List detect(optionalIndex, value, message)\n"
  	"    Returns the first value for which the message evaluates to a non-nil. Example:\n"
  	"<pre>list(1, 2, 3, 4) detect(i, v, v > 2)\n"
  	"==> 3\n"
  	"list(1, 2, 3, 4) detect(v, v > 2)\n"
  	"==> 3</pre>\n"
  	"*/\n"
  	"    detect := method(\n"
  	"        # Creating a context, in which the body would be executed in.\n"
  	"        context := Object clone prependProto(call sender)\n"
  	"        # Note: this is needed for the Object_forwardLocals() method to\n"
  	"        # work correctly. See IoObject.c:870.\n"
  	"        if(call sender hasLocalSlot(\"self\"),\n"
  	"            context setSlot(\"self\", call sender self)\n"
  	"        )\n"
  	"        argCount := call argCount\n"
  	"\n"
  	"        if(argCount == 0, Exception raise(\"missing argument\"))\n"
  	"        if(argCount == 1) then(\n"
  	"            body := call argAt(0)\n"
  	"            self foreach(value,\n"
  	"                if(getSlot(\"value\") doMessage(body, context),\n"
  	"                    return getSlot(\"value\")\n"
  	"                )\n"
  	"            )\n"
  	"        ) elseif(argCount == 2) then(\n"
  	"            eName := call argAt(0) name # Element.\n"
  	"            body  := call argAt(1)\n"
  	"            self foreach(value,\n"
  	"                context setSlot(eName, getSlot(\"value\"))\n"
  	"                if(context doMessage(body), return getSlot(\"value\"))\n"
  	"            )\n"
  	"        ) else(\n"
  	"            iName := call argAt(0) name # Index.\n"
  	"            eName := call argAt(1) name # Element.\n"
  	"            body  := call argAt(2)\n"
  	"\n"
  	"            self foreach(idx, value,\n"
  	"                context setSlot(iName, idx)\n"
  	"                context setSlot(eName, getSlot(\"value\"))\n"
  	"                if(context doMessage(body), return getSlot(\"value\"))\n"
  	"            )\n"
  	"        )\n"
  	"        nil # If nothing found, return nil.\n"
  	"    )\n"
  	"\n"
  	"    /*doc List mapInPlace(optionalIndex, value, message)\n"
  	"    Replaces each item in the receiver with the result of applying a given message\n"
  	"    to that item. Example:\n"
  	"<pre>list(1, 5, 7, 2) mapInPlace(i, v, i + v)\n"
  	"==> list(1, 6, 9, 5)\n"
  	"list(1, 5, 7, 2) mapInPlace(v, v + 3)\n"
  	" ==> list(4, 8, 10, 5)</pre>\n"
  	"    */\n"
  	"    mapInPlace := method(\n"
  	"        # Creating a context, in which the body would be executed in.\n"
  	"        context := Object clone prependProto(call sender)\n"
  	"        # Note: this is needed for the Object_forwardLocals() method to\n"
  	"        # work correctly. See IoObject.c:870.\n"
  	"        if(call sender hasLocalSlot(\"self\"),\n"
  	"            context setSlot(\"self\", call sender self)\n"
  	"        )\n"
  	"        argCount := call argCount\n"
  	"\n"
  	"        if(argCount == 0, Exception raise(\"missing argument\"))\n"
  	"        if(argCount == 1) then(\n"
  	"            body := call argAt(0)\n"
  	"            self foreach(idx, value,\n"
  	"                atPut(idx, getSlot(\"value\") doMessage(body, context))\n"
  	"            )\n"
  	"        ) elseif(argCount == 2) then(\n"
  	"            eName := call argAt(0) name # Element.\n"
  	"            body  := call argAt(1)\n"
  	"            self foreach(idx, value,\n"
  	"                context setSlot(eName, getSlot(\"value\"))\n"
  	"                atPut(idx, context doMessage(body))\n"
  	"            )\n"
  	"        ) else(\n"
  	"            iName := call argAt(0) name # Index.\n"
  	"            eName := call argAt(1) name # Element.\n"
  	"            body  := call argAt(2)\n"
  	"\n"
  	"            self foreach(idx, value,\n"
  	"                context setSlot(iName, idx)\n"
  	"                context setSlot(eName, getSlot(\"value\"))\n"
  	"                atPut(idx, context doMessage(body))\n"
  	"            )\n"
  	"        )\n"
  	"        self\n"
  	"    )\n"
  	"\n"
  	"    //doc List map Same as <tt>mapInPlace</tt>, but returns results in a new List.\n"
  	"    map := method(\n"
  	"        call delegateToMethod(self clone, \"mapInPlace\")\n"
  	"    )\n"
  	"\n"
  	"    //doc List copy(v) Replaces self with <tt>v</tt> list items. Returns self.\n"
  	"    copy := method(v, self empty; self appendSeq(v); self)\n"
  	"\n"
  	"    empty := method(self removeAll)\n"
  	"\n"
  	"    isEmpty := method(size == 0)\n"
  	"    isNotEmpty := method(size > 0)\n"
  	"\n"
  	"    //doc List reverse Reverses the ordering of all the items of the receiver. Returns copy of receiver.\n"
  	"    reverse := method(itemCopy reverseInPlace)\n"
  	"\n"
  	"    //doc List itemCopy Returns a new list containing the items from the receiver.\n"
  	"    itemCopy := method(List clone copy(self))\n"
  	"\n"
  	"    //doc List sort Returns a new list containing the sorted items from the receiver.\n"
  	"    sort := method(self clone sortInPlace)\n"
  	"    /*doc List sortBy(aBlock)\n"
  	"        Returns a new list containing the items from the receiver, sorted using aBlock as compare function. Example:\n"
  	"<code>list(1, 3, 2, 4, 0) sortBy(block(a, b, a > b))\n"
  	"==> list(4, 3, 2, 1, 0)</code>\n"
  	"*/\n"
  	"    sortBy := method(b, self clone sortInPlaceBy(getSlot(\"b\")))\n"
  	"\n"
  	"    //doc List second Returns second element (same as <tt>at(1)</tt>)\n"
  	"    second := method(at(1))\n"
  	"    //doc List second Returns third element (same as <tt>at(2)</tt>)\n"
  	"    third := method(at(2))\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "A0_List.io");

	s = "//doc Object addTrait Takes another object, whose slots will be copied into the receiver. Optionally takes a second argument, a Map object containing string -> string pairs, holding conflicting slot names and names to rename them to. I.e., if you have two objects A and B, both have a slot named foo, you issue A addTrait(B, Map clone atPut(\"foo\", \"newFoo\")) the value of B foo will be placed in A newFoo.\n"
  	"Object addTrait := method(obj,\n"
  	"  if(call message arguments size == 0, \n"
  	"    Exception raise(\"addTrait requires at least one argument\"))\n"
  	"  resolutions := call evalArgAt(1)\n"
  	"  if(resolutions isNil, resolutions = Map clone)\n"
  	"\n"
  	"  getSlot(\"obj\") foreachSlot(name, value,\n"
  	"    if(getSlot(\"self\") hasLocalSlot(name),\n"
  	"      if(name == \"type\", continue)\n"
  	"      if(resolutions at(name) isNil, Exception raise(\"\"\"Slot '#{name}' already exists in #{getSlot(\"self\") type}[#{getSlot(\"self\") uniqueId}]. Give it a new name in the map argument.\"\"\" interpolate))\n"
  	"      getSlot(\"self\") setSlot(resolutions at(name), getSlot(\"value\"))\n"
  	"      continue\n"
  	"    )\n"
  	"    getSlot(\"self\") setSlot(name, getSlot(\"value\"))\n"
  	"  )\n"
  	"\n"
  	"  getSlot(\"self\")\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "A0_Object.io");

	s = "OperatorTable do(\n"
  	"	addOperator := method(symbol, precedence,\n"
  	"		precedence = precedence ifNilEval(0)\n"
  	"		operators atPut(symbol, precedence)\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	addAssignOperator := method(symbol, messageName,\n"
  	"		assignOperators atPut(symbol, messageName)\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	asString := method(\n"
  	"		s := Sequence clone appendSeq(OperatorTable asSimpleString, \":\\n\")\n"
  	"\n"
  	"		s appendSeq(\"Operators\")\n"
  	"		OperatorTable operators values unique sort foreach(precedence,\n"
  	"			s appendSeq(\"\\n  \", precedence asString alignLeft(4), OperatorTable operators select(k, v, v == precedence) keys sort join(\" \"))\n"
  	"		)\n"
  	"\n"
  	"		s appendSeq(\"\\n\\nAssign Operators\")\n"
  	"		OperatorTable assignOperators keys sort foreach(symbol,\n"
  	"			name := OperatorTable assignOperators at(symbol)\n"
  	"			s appendSeq(\"\\n  \", symbol alignLeft(4), name)\n"
  	"		)\n"
  	"\n"
  	"		s appendSeq(\"\\n\\n\")\n"
  	"		s appendSeq(\"To add a new operator: OperatorTable addOperator(\\\"+\\\", 4) and implement the + message.\\n\")\n"
  	"		s appendSeq(\"To add a new assign operator: OperatorTable addAssignOperator(\\\"=\\\", \\\"updateSlot\\\") and implement the updateSlot message.\\n\")\n"
  	"\n"
  	"		s\n"
  	"	)\n"
  	"\n"
  	"	reverseAssignOperators := method(assignOperators reverseMap)\n"
  	")\n"
  	"\n"
  	"# Make the lookup path shorter for the opShuffle. IoMessage_opShuffle looks up\n"
  	"# the OperatorTable object on the first message before starting shuffling.\n"
  	"Message OperatorTable := OperatorTable\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "A1_OperatorTable.io");

	s = "/*\n"
  	"//metadoc nil description nil is a singleton object that is used as a placeholder and to mean false in Io.\")\n"
  	"\n"
  	"nil do(\n"
  	"	//doc nil clone returns self since nil is a singleton.\n"
  	"	clone := nil\n"
  	"\n"
  	"	//doc nil and(expression) Returns nil without evaluating expression.\n"
  	"	setSlot(\"and\", nil)\n"
  	"\n"
  	"	elseif := Object getSlot(\"if\")\n"
  	"\n"
  	"	//doc nil then(expression) Returns nil without evaluating expression.\n"
  	"	setSlot(\"then\", nil)\n"
  	"\n"
  	"	//doc nil else(expression) Returns nil without evaluating expression.\n"
  	"	setSlot(\"else\", method(v, v))\n"
  	"\n"
  	"	//doc nil or(anObject) Returns anObject if anObject is not nil. Otherwise returns nil.\n"
  	"	setSlot(\"or\", method(v, if(v, v, nil)))\n"
  	"\n"
  	"	//doc nil print Prints 'nil'. Returns self.\n"
  	"	print := method(write(\"nil\"))\n"
  	"\n"
  	"	setSlot(\"==\", method(v, self isIdenticalTo(v)))\n"
  	"	setSlot(\"!=\", method(v, self isIdenticalTo(v) not))\n"
  	"\n"
  	"	//doc nil isNil Returns Lobby.\n"
  	"	isNil := Lobby\n"
  	"\n"
  	"	//doc nil ifNil(expression) Evaluates message.\n"
  	"	ifNil := method(v, v)\n"
  	")\n"
  	"*/\n"
  	"\n"
  	"// if(a == 1) then(b) elseif(b == c) then(d) else(f)\n"
  	"// (a == 1) ifTrue(b) ifFalse(c)\n"
  	"\n"
  	"true do(\n"
  	"	//doc true then Evaluates the argument and returns nil.\n"
  	"	then    := Object getSlot(\"evalArgAndReturnNil\")\n"
  	"\n"
  	"	//doc true elseif Does not eval argument and returns true.\n"
  	"	elseif  := true\n"
  	"\n"
  	"	//doc true else Does not eval argument and returns true.\n"
  	"	else    := true\n"
  	"\n"
  	"	//doc true ifTrue Evaluates the argument and returns self.\n"
  	"	ifTrue  := Object getSlot(\"evalArgAndReturnSelf\")\n"
  	"	\n"
  	"	//doc true ifFalse Does not eval argument and returns true.\n"
  	"	ifFalse := true\n"
  	"	\n"
  	"	//doc true and Evaluates the argument and returns the result.\n"
  	"	\n"
  	"	//doc true or Does not eval argument and returns true.\n"
  	"	setSlot(\"or\", true)\n"
  	"\n"
  	"	//doc true asString Returns true.\n"
  	"	asString := \"true\"\n"
  	"\n"
  	"	//doc true asSimpleString Returns true.\n"
  	"	asSimpleString := \"true\"\n"
  	"\n"
  	"	//doc true not Does not eval argument and returns false.\n"
  	"	not := false\n"
  	"	\n"
  	"	//doc true clone Returns true.\n"
  	"	clone := true\n"
  	")\n"
  	"\n"
  	"false do(\n"
  	"  //doc false then Returns false.\n"
  	"	then    := false\n"
  	"	//doc false ifTrue Returns false.\n"
  	"	ifTrue  := false\n"
  	"	//doc false ifFalse Evaluates the argument and returns self.\n"
  	"	ifFalse := Object getSlot(\"evalArgAndReturnSelf\")\n"
  	"	//doc false elseif Same as <tt>if</tt>.\n"
  	"	elseif  := Object getSlot(\"if\")\n"
  	"	//doc false else Evaluates the argument and returns nil.\n"
  	"	else    := Object getSlot(\"evalArgAndReturnNil\")\n"
  	"	//doc false and Returns false.\n"
  	"	setSlot(\"and\", false)\n"
  	"	//doc false or Evaluates the argument and returns the result.\n"
  	"	or := method(v, v isTrue)\n"
  	"  \n"
  	"  //doc false type Returns \"false\".\n"
  	"	type := \"false\"\n"
  	"	//doc false asString Returns \"false\".\n"
  	"	asString := \"false\"\n"
  	"	//doc false asSimpleString Returns \"false\".\n"
  	"	asSimpleString := \"false\"\n"
  	"	//doc false not Returns true.\n"
  	"	not := true\n"
  	"	//doc false clone Returns self.\n"
  	"	clone := false\n"
  	"	isTrue := false\n"
  	")\n"
  	"\n"
  	"nil do(\n"
  	"	not := true\n"
  	"	isNil := true\n"
  	"\n"
  	"	ifNonNil := Object getSlot(\"thisContext\")\n"
  	"	ifNil := Object getSlot(\"evalArgAndReturnSelf\")\n"
  	"\n"
  	"	ifNilEval    := Object getSlot(\"evalArg\")\n"
  	"	ifNonNilEval := Object getSlot(\"thisContext\")\n"
  	"\n"
  	"	type := \"nil\"\n"
  	"	asString := type\n"
  	"	asSimpleString := type\n"
  	"\n"
  	"	setSlot(\"and\", false)\n"
  	"	or := method(v, v isTrue)\n"
  	"	then := nil\n"
  	"	else := nil\n"
  	"	elseif := nil\n"
  	"	clone := nil\n"
  	"	isTrue := false\n"
  	")\n"
  	"\n"
  	"// I think non-local returns can eliminate all this stopStatus stuff \n"
  	"\n"
  	"Call do(\n"
  	"  /*doc Call relayStopStatus(arg) \n"
  	"  Sets sender's stop status (Normal, Return, \n"
  	"  Break, Continue etc.) and returns evaluated argument.\n"
  	"  */\n"
  	"	relayStopStatus := method(\n"
  	"		ss := stopStatus(r := call evalArgAt(0))\n"
  	"		call sender call setStopStatus(ss)\n"
  	"		getSlot(\"r\")\n"
  	"	)\n"
  	"\n"
  	"  /*doc Call resetStopStatus(arg) \n"
  	"  Sets stop status to Normal.\n"
  	"  See also <tt>Call setStopStatus</tt>.\n"
  	"  */\n"
  	"	resetStopStatus := method(\n"
  	"		setStopStatus(Normal)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Normal do(\n"
  	"	stopLooping := false\n"
  	"	isReturn := false\n"
  	"	isBreak := false\n"
  	"	isContinue := false\n"
  	"\n"
  	"	return := method(arg,\n"
  	"		call setStopStatus(Return)\n"
  	"		getSlot(\"arg\")\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Eol appendProto(Normal)\n"
  	"Continue appendProto(Normal) do(\n"
  	"	isContinue := true\n"
  	")\n"
  	"\n"
  	"Break appendProto(Normal) do(\n"
  	"	stopLooping := true\n"
  	"	isBreak := true\n"
  	")\n"
  	"\n"
  	"Return appendProto(Normal) do(\n"
  	"	stopLooping := true\n"
  	"	isReturn := true\n"
  	"\n"
  	"	return := method(arg,\n"
  	"		call setStopStatus(Return)\n"
  	"		call sender call setStopStatus(Return)\n"
  	"		getSlot(\"arg\")\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"	//doc Object not Returns nil.\n"
  	"	not := nil\n"
  	"	//doc Object isNil Returns false.\n"
  	"	isNil := false\n"
  	"	//doc Object ifNil(arg) Does nothing, returns self.\n"
  	"	ifNil := Object getSlot(\"thisContext\")\n"
  	"	//doc Object ifNonNil(arg) Evaluates argument and returns self.\n"
  	"	ifNonNil := Object getSlot(\"evalArgAndReturnSelf\")\n"
  	"	//doc Object ifNonNilEval(arg) Evaluates argument and returns the result.\n"
  	"	ifNonNilEval := Object getSlot(\"evalArg\")\n"
  	"	//doc Object ifNilEval(arg) Does nothing, returns self.\n"
  	"	ifNilEval    := Object getSlot(\"thisContext\")\n"
  	"	//doc Object or(arg) Returns true.\n"
  	"	setSlot(\"or\", true)\n"
  	"	\n"
  	"	//doc Object isTrue Returns true.\n"
  	"	isTrue := true\n"
  	"	//doc Object and(arg) Evaluates argument and returns the result.\n"
  	"	and := method(v, v isTrue)\n"
  	")\n"
  	"\n"
  	"Sequence do(\n"
  	"  /*doc Sequence makeFirstCharacterLowercase \n"
  	"  Receiver must be mutable (see also asMutable). Returns receiver.\n"
  	"  <br/>\n"
  	"  <pre>\n"
  	"  Io> \"ABC\" asMutable makeFirstCharacterLowercase\n"
  	"  ==> aBC\n"
  	"  </pre>\n"
  	"  */\n"
  	"	makeFirstCharacterLowercase := method(\n"
  	"		if(self size > 0, self atPut(0, self at(0) asLowercase))\n"
  	"	)\n"
  	"  /*doc Sequence makeFirstCharacterUppercase \n"
  	"  Receiver must be mutable (see also asMutable). Returns receiver.\n"
  	"  <br/>\n"
  	"  <pre>\n"
  	"  Io> \"abc\" asMutable makeFirstCharacterUppercase\n"
  	"  ==> Abc\n"
  	"  </pre>\n"
  	"  */\n"
  	"	makeFirstCharacterUppercase := method(\n"
  	"		if(self size > 0, self atPut(0, self at(0) asUppercase))\n"
  	"	)\n"
  	"\n"
  	"  /*doc Sequence slicesBetween(startSeq, endSeq) \n"
  	"  Returns a list of slices delimited \n"
  	"  by <tt>startSeq</tt> and <tt>endSeq</tt>.\n"
  	"  <br>\n"
  	"  <pre>\n"
  	"  Io> \"<a><b></b></a>\" slicesBetween(\"<\", \">\")\n"
  	"  ==> list(\"a\", \"b\", \"/b\", \"/a\")\n"
  	"  </pre>\n"
  	"  */\n"
  	"	slicesBetween := method(startSeq, endSeq,\n"
  	"		chunks := List clone\n"
  	"		lastIndex := 0\n"
  	"		while (startIndex := self findSeq(startSeq, lastIndex),\n"
  	"			endIndex := self findSeq(endSeq, startIndex + startSeq size)\n"
  	"			endIndex ifNil(break)\n"
  	"			chunks append(self exclusiveSlice(startIndex + startSeq size, endIndex))\n"
  	"			lastIndex := endIndex + endSeq size\n"
  	"		)\n"
  	"		chunks\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"  /*doc Object hasSlot(name) \n"
  	"  Returns <tt>true</tt> if slot is found somewhere in the inheritance chain \n"
  	"  (including receiver itself).\n"
  	"  */\n"
  	"	hasSlot := method(n,\n"
  	"		getSlot(\"self\") hasLocalSlot(n) or(getSlot(\"self\") ancestorWithSlot(n) != nil)\n"
  	"	)\n"
  	"\n"
  	"	//doc Object list(...) Returns a List containing the arguments.\n"
  	"	list := method(call message argsEvaluatedIn(call sender))\n"
  	"\n"
  	"	//doc Object ..(arg) .. is an alias for: method(arg, self asString append(arg asString))\n"
  	"	setSlot(\"..\", method(arg, getSlot(\"self\") asString .. arg asString))\n"
  	"\n"
  	"	Map addKeysAndValues := method(keys, values, keys foreach(i, k, self atPut(k, values at(i))); self)\n"
  	"  \n"
  	"  /*doc Object slotDescriptionMap\n"
  	"  Returns raw map of slot names and short values' descriptions.\n"
  	"  See also <tt>Object slotSummary</tt>.\n"
  	"  */\n"
  	"	slotDescriptionMap := method(\n"
  	"		slotNames := getSlot(\"self\") slotNames sort\n"
  	"		slotDescs := slotNames map(name, getSlot(\"self\") getSlot(name) asSimpleString)\n"
  	"		Map clone addKeysAndValues(slotNames, slotDescs)\n"
  	"	)\n"
  	"  //doc Object apropos Prints out <tt>Protos Core</tt> slot descriptions.\n"
  	"	apropos := method(keyword,\n"
  	"		Protos Core foreachSlot(name, p,\n"
  	"			slotDescriptions := getSlot(\"p\") slotDescriptionMap ?select(k, v, k asMutable lowercase containsSeq(keyword))\n"
  	"\n"
  	"			if(slotDescriptions and slotDescriptions size > 0,\n"
  	"				s := Sequence clone\n"
  	"				slotDescriptions keys sortInPlace foreach(k,\n"
  	"					s appendSeq(\"  \", k alignLeft(16), \" = \", slotDescriptions at(k), \"\\n\")\n"
  	"				)\n"
  	"\n"
  	"				writeln(name)\n"
  	"				writeln(s)\n"
  	"			)\n"
  	"		)\n"
  	"		nil\n"
  	"	)\n"
  	"  /*doc Object slotSummary \n"
  	"  Returns a formatted <tt>slotDescriptionMap</tt>.\n"
  	"  <br/>\n"
  	"  <pre>\n"
  	"  Io> slotSummary\n"
  	"  ==>  Object_0x30c590:\n"
  	"    Lobby            = Object_0x30c590\n"
  	"    Protos           = Object_0x30c880\n"
  	"    exit             = method(...)\n"
  	"    forward          = method(...)\n"
  	"  </pre>\n"
  	"  */\n"
  	"  \n"
  	"	slotSummary := method(keyword,\n"
  	"		if(getSlot(\"self\") type == \"Block\",\n"
  	"			return getSlot(\"self\") asSimpleString\n"
  	"		)\n"
  	"		\n"
  	"		s := Sequence clone\n"
  	"		s appendSeq(\" \", getSlot(\"self\") asSimpleString, \":\\n\")\n"
  	"		slotDescriptions := slotDescriptionMap\n"
  	"		\n"
  	"		if(keyword,\n"
  	"			slotDescriptions = slotDescriptions select(k, v, k asMutable lowercase containsSeq(keyword))\n"
  	"		)\n"
  	"		\n"
  	"		slotDescriptions keys sortInPlace foreach(k,\n"
  	"			s appendSeq(\"  \", k alignLeft(16), \" = \", slotDescriptions at(k), \"\\n\")\n"
  	"		)\n"
  	"		s\n"
  	"	)\n"
  	"  \n"
  	"  //doc Object asString Same as <tt>slotSummary</tt>.\n"
  	"	asString := getSlot(\"slotSummary\")\n"
  	"\n"
  	"  //doc Object asSimpleString Returns <type>_<uniqueHexId> string.\n"
  	"	asSimpleString := method(getSlot(\"self\") type .. \"_\" .. getSlot(\"self\") uniqueHexId)\n"
  	"\n"
  	"	/*doc Object newSlot(slotName, aValue)\n"
  	"	Creates a getter and setter for the slot with the name slotName\n"
  	"	and sets its default value to aValue. Returns self. For example,\n"
  	"	newSlot(\"foo\", 1) would create slot named foo with the value 1 as well as a setter method setFoo().\n"
  	"	*/\n"
  	"\n"
  	"	newSlot := method(name, value, doc,\n"
  	"		getSlot(\"self\") setSlot(name, getSlot(\"value\"))\n"
  	"		getSlot(\"self\") setSlot(\"set\" .. name asCapitalized,\n"
  	"			doString(\"method(\" .. name .. \" = call evalArgAt(0); self)\"))\n"
  	"			//if(doc, getSlot(\"self\") docSlot(name, doc))\n"
  	"		getSlot(\"value\")\n"
  	"	)\n"
  	"\n"
  	"	//doc Object launchFile(pathString) Eval file at pathString as if from the command line in its folder.\n"
  	"  //doc System launchPath Returns a pathComponent of the launch file.\n"
  	"	launchFile := method(path, args,\n"
  	"		args ifNil(args = List clone)\n"
  	"		System launchPath :=  path pathComponent\n"
  	"		Directory setCurrentWorkingDirectory(System launchPath)\n"
  	"		System launchScript = path\n"
  	"		self doFile(path)\n"
  	"	)\n"
  	"\n"
  	"	//doc Object println Same as print, but also prints a new line. Returns self.\n"
  	"	println := method(getSlot(\"self\") print; write(\"\\n\"); self)\n"
  	"\n"
  	"	/*doc Object ?(aMessage)\n"
  	"	description: Sends the message aMessage to the receiver if it can respond to it. Example:\n"
  	"	<pre>\n"
  	"	MyObject test // performs test\n"
  	"	MyObject ?test // performs test if MyObject has a slot named test\n"
  	"	</pre>\n"
  	"	The search for the slot only follows the receivers proto chain.\n"
  	"	*/\n"
  	"\n"
  	"	setSlot(\"?\",\n"
  	"		method(\n"
  	"			m := call argAt(0)\n"
  	"			if (self getSlot(m name) != nil,\n"
  	"				call relayStopStatus(m doInContext(self, call sender))\n"
  	"			,\n"
  	"				nil\n"
  	"			)\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	//doc Object ancestors Returns a list of all of the receiver's ancestors as found by recursively following the protos links.\n"
  	"\n"
  	"	ancestors := method(a,\n"
  	"	  if(a, if(a detect(x, getSlot(\"x\") isIdenticalTo(getSlot(\"self\"))), return a), a = List clone)\n"
  	"	  a append(getSlot(\"self\"))\n"
  	"	  self protos foreach(ancestors(a))\n"
  	"	  a\n"
  	"	)\n"
  	"\n"
  	"	//doc Object isKindOf(anObject) Returns true if anObject is in the receiver's ancestors.\n"
  	"\n"
  	"	isKindOf := method(anObject, getSlot(\"self\") ancestors contains(getSlot(\"anObject\")))\n"
  	"\n"
  	"	/*doc Object super(aMessage)\n"
  	"	Sends the message aMessage to the receiver's proto with the context of self. Example:\n"
  	"	<pre>\n"
  	"	self test(1, 2)   // performs test(1, 2) on self\n"
  	"	super(test(1, 2)) // performs test(1, 2) on self proto but with the context of self\n"
  	"	</pre>\n"
  	"	*/\n"
  	"\n"
  	"	setSlot(\"super\", method(\n"
  	"		senderSlotContext := call sender call slotContext\n"
  	"		m := call argAt(0)\n"
  	"		m ifNil(Exception raise(\"Object super requires an argument\"))\n"
  	"		senderSlotContext ifNil(Exception raise(\"Object super called outside of block context\"))\n"
  	"		slotName := m name\n"
  	"		ancestor := senderSlotContext ancestorWithSlot(slotName)\n"
  	"		if(ancestor == nil,\n"
  	"			slotName = \"forward\"\n"
  	"			ancestor = senderSlotContext ancestorWithSlot(slotName)\n"
  	"		)\n"
  	"		if(ancestor isIdenticalTo(senderSlotContext), Exception raise(\"Object super slot \" .. slotName .. \" not found\"))\n"
  	"		b := ancestor getSlot(slotName)\n"
  	"		if(getSlot(\"b\") isActivatable == false,\n"
  	"			b\n"
  	"		,\n"
  	"			getSlot(\"b\") performOn(call sender call target, call sender, m, ancestor)\n"
  	"		)\n"
  	"	))\n"
  	"\n"
  	"	/*doc Object resend\n"
  	"	Send the message used to activate the current method to the Object's proto.\n"
  	"  For example:\n"
  	"  <pre>\n"
  	"  Dog := Mammal clone do(\n"
  	"    init := method(\n"
  	"  	  resend\n"
  	"    )\n"
  	"  )\n"
  	"  </pre>\n"
  	"	Calling Dog init will send an init method to Mammal, but using the Dog's context.\n"
  	"	*/\n"
  	"\n"
  	"	setSlot(\"resend\", method(\n"
  	"		senderSlotContext := call sender call slotContext\n"
  	"		senderSlotContext ifNil(Exception raise(\"Object resend called outside of block context\"))\n"
  	"		m := call sender call message\n"
  	"		slotName := m name\n"
  	"		ancestor := senderSlotContext ancestorWithSlot(slotName)\n"
  	"\n"
  	"		if(ancestor isIdenticalTo(nil),\n"
  	"			slotName = \"forward\"\n"
  	"			ancestor = senderSlotContext ancestorWithSlot(slotName)\n"
  	"		)\n"
  	"\n"
  	"		if(ancestor isIdenticalTo(senderSlotContext),\n"
  	"			Exception raise(\"Object resend slot \" .. slotName .. \" not found\")\n"
  	"		)\n"
  	"\n"
  	"		b := ancestor getSlot(slotName)\n"
  	"		if(getSlot(\"b\") != nil,\n"
  	"			getSlot(\"b\") performOn(call sender getSlot(\"self\"), call sender call sender, m, ancestor)\n"
  	"		,\n"
  	"			getSlot(\"b\")\n"
  	"		)\n"
  	"	))\n"
  	"\n"
  	"\n"
  	"	//doc Object list(...) Returns a List containing the arguments.\n"
  	"	list := method(call message argsEvaluatedIn(call sender))\n"
  	"\n"
  	"	Object print := method(write(getSlot(\"self\") asString); getSlot(\"self\"))\n"
  	"\n"
  	"	//doc Object println Same as print, but also prints a new line. Returns self.\n"
  	"	println := method(getSlot(\"self\") print; write(\"\\n\"); getSlot(\"self\"))\n"
  	"\n"
  	"	//doc Object in(aList) Same as: aList contains(self)\n"
  	"	in := method(aList, aList contains(self))\n"
  	"\n"
  	"  /*doc Object uniqueHexId \n"
  	"  Returns uniqueId in a hexadecimal form (with a \"0x\" prefix)\n"
  	"  <pre>\n"
  	"  Io> Object uniqueId\n"
  	"  ==> 3146784\n"
  	"  Io> Object uniqueHexId\n"
  	"  ==> 0x300420\n"
  	"  </pre>\n"
  	"  */\n"
  	"	uniqueHexId := method(\"0x\" .. getSlot(\"self\") uniqueId asString toBase(16))\n"
  	"\n"
  	"  /*doc Object lazySlot(code) \n"
  	"  Defines a slot with a lazy initialization code. \n"
  	"  Code is run only once: the first time slot is accessed. \n"
  	"  Returned value is stored in a regular slot.\n"
  	"  <br/>\n"
  	"  <pre>\n"
  	"  Io> x := lazySlot(\"Evaluated!\" println; 17)\n"
  	"  Io> x\n"
  	"  Evaluated!\n"
  	"  ==> 17\n"
  	"  Io> x\n"
  	"  ==> 17\n"
  	"  Io> x\n"
  	"  ==> 17\n"
  	"  </pre>\n"
  	"  <br/>\n"
  	"  Another form is <tt>lazySlot(name, code)</tt>:\n"
  	"  <br/>\n"
  	"  <pre>\n"
  	"  Io> lazySlot(\"x\", \"Evaluated!\" println; 17)\n"
  	"  Io> x\n"
  	"  Evaluated!\n"
  	"  ==> 17\n"
  	"  Io> x\n"
  	"  ==> 17\n"
  	"  Io> x\n"
  	"  ==> 17\n"
  	"  </pre>\n"
  	"  */\n"
  	"	lazySlot := method(\n"
  	"		if(call argCount == 1,\n"
  	"			m := method(\n"
  	"				self setSlot(call message name, nil)\n"
  	"			)\n"
  	"\n"
  	"			args := getSlot(\"m\") message next arguments\n"
  	"			args atPut(1, call argAt(0) clone)\n"
  	"			getSlot(\"m\") message next setArguments(args)\n"
  	"\n"
  	"			getSlot(\"m\") clone\n"
  	"		,\n"
  	"			name := call evalArgAt(0)\n"
  	"			m := (\"self setSlot(\\\"\" .. name .. \"\\\", \" .. call argAt(1) code .. \")\") asMessage\n"
  	"			self setSlot(name, method() setMessage(m))\n"
  	"			nil\n"
  	"		)\n"
  	"	)\n"
  	"  \n"
  	"  /*doc Object foreachSlot(slotName, slotValue, code)\n"
  	"  Iterates over all the slots in a receiver. Provides slotValue (non-activated)\n"
  	"  along with slotName. Code is executed in context of sender. <tt>slotName</tt> and <tt>slotValue</tt>\n"
  	"  become visible in the receiver (no Locals created! Maybe, it is not the best decision).\n"
  	"  <br/>\n"
  	"  <pre>\n"
  	"  Io> thisContext foreachSlot(n, v, n println)\n"
  	"  Lobby\n"
  	"  Protos\n"
  	"  exit\n"
  	"  forward\n"
  	"  n\n"
  	"  v\n"
  	"  ==> false\n"
  	"  </pre>\n"
  	"  */\n"
  	"	foreachSlot := method(\n"
  	"		self slotNames sort foreach(n,\n"
  	"			call sender setSlot(call message argAt(0) name, n)\n"
  	"			call sender setSlot(call message argAt(1) name, getSlot(\"self\") getSlot(n))\n"
  	"			r := call relayStopStatus(call evalArgAt(2))\n"
  	"			if(call stopStatus isReturn, return getSlot(\"r\"))\n"
  	"			if(call stopStatus stopLooping,\n"
  	"				call resetStopStatus\n"
  	"				break\n"
  	"			)\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	/*doc Object switch(<key1>, <expression1>, <key2>, <expression2>, ...) \n"
  	"	Execute an expression depending on the value of the caller. (This is an equivalent to C switch/case)\n"
  	"	<code>\n"
  	"	hour := Date hour switch(\n"
  	"		12, \"midday\",\n"
  	"		0, \"midnight\",\n"
  	"		17, \"teatime\",\n"
  	"		Date hour asString\n"
  	"	)\n"
  	"	</code>\n"
  	"	*/\n"
  	"	\n"
  	"	switch := method(\n"
  	"		for(couple, 0, call argCount - 2, 2,\n"
  	"			if(call evalArgAt(couple) == self,\n"
  	"				return call relayStopStatus(call evalArgAt(couple + 1))\n"
  	"			)\n"
  	"		)\n"
  	"		if(call argCount isOdd,\n"
  	"			call relayStopStatus(call evalArgAt(call argCount - 1))\n"
  	"		,\n"
  	"			nil\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	//doc Object isLaunchScript Returns true if the current file was run on the command line. Io's version of Python's __file__ == \"__main__\"\n"
  	"	isLaunchScript := method(\n"
  	"		call message label == System launchScript\n"
  	"	)\n"
  	"\n"
  	"	/*doc Object doRelativeFile(pathString)\n"
  	"		Evaluates the File in the context of the receiver. Returns the result. \n"
  	"		pathString is relative to the file calling doRelativeFile. (Duplicate of relativeDoFile)\n"
  	"	*/\n"
  	"	doRelativeFile := method(path,\n"
  	"		self doFile(Path with(call message label pathComponent, path))\n"
  	"	)\n"
  	"\n"
  	"	/*doc Object relativeDoFile(pathString)\n"
  	"		Evaluates the File in the context of the receiver. Returns the result. \n"
  	"		pathString is relative to the file calling doRelativeFile. (Duplicate of doRelativeFile)\n"
  	"	*/\n"
  	"	relativeDoFile := getSlot(\"doRelativeFile\")\n"
  	"	\n"
  	"	/*doc Object deprecatedWarning(optionalNewName) \n"
  	"	Prints a warning message that the current method is deprecated.\n"
  	"	If optionalNewName is supplied, the warning will suggest using that instead.\n"
  	"	Returns self.\n"
  	"	*/\n"
  	"	Object deprecatedWarning := method(newName,\n"
  	"		writeln(\"Warning in \", call sender call message label, \": '\", call sender call message name, \"' is deprecated\", if(newName, \".  Use '\" .. newName .. \"' instead.\", \" and will be removed from a later version.\"))\n"
  	"		self\n"
  	"	)\n"
  	"	\n"
  	"	//referenceIdForObject := method(obj, getSlot(\"obj\") unqiueId)\n"
  	"	//objectForReferenceId := method(id, Collector objectWithUniqueId(id))\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "A2_Object.io");

	s = "List do(\n"
  	"    //doc List sum Returns the sum of the items.\n"
  	"    sum := method(self reduce(+))\n"
  	"\n"
  	"    //doc List average Returns the average of the items.\n"
  	"    average := method(self sum / self size)\n"
  	"\n"
  	"    //doc List removeFirst Returns the first item and removes it from the list. nil is returned if the list is empty.\n"
  	"    removeFirst := method(if(self size != 0, removeAt(0), nil))\n"
  	"\n"
  	"    //doc List removeLast Returns the last item and removes it from the list. nil is returned if the list is empty.\n"
  	"    removeLast := method(self pop)\n"
  	"\n"
  	"    //doc List removeSeq Removes each of the items from the current list which are contained in the sequence passed in.\n"
  	"    removeSeq := method(seq,\n"
  	"        seq foreach(x, self remove(x))\n"
  	"        self\n"
  	"    )\n"
  	"\n"
  	"    //doc List rest Returns a copy of the list but with the first element removed.\n"
  	"    rest := method(slice(1))\n"
  	"\n"
  	"    /*doc List join(optionalSeparator)\n"
  	"    Returns a Sequence of the concatenated items with\n"
  	"    optionalSeparator between each item or simply the concatenation of the items if no optionalSeparator is supplied.\n"
  	"    */\n"
  	"    join := method(sep,\n"
  	"        result := Sequence clone\n"
  	"        if(sep,\n"
  	"            max := self size - 1\n"
  	"            self foreach(idx, value,\n"
  	"                result appendSeq(value)\n"
  	"                if(idx != max, result appendSeq(sep))\n"
  	"            )\n"
  	"        ,\n"
  	"            self foreach(value, result appendSeq(value))\n"
  	"        )\n"
  	"    result)\n"
  	"\n"
  	"    /*doc List insertAfter(item, afterItem)\n"
  	"    Inserts item after first occurance of afterItem and returns self. If afterItem\n"
  	"    is not found, item is appended to the end of the list.\n"
  	"    */\n"
  	"    insertAfter := method(item, afterItem,\n"
  	"        i := self indexOf(afterItem)\n"
  	"        if(i, self atInsert(i + 1, item), self append(item))\n"
  	"        self\n"
  	"    )\n"
  	"\n"
  	"    /*doc List insertBefore(item, beforeItem)\n"
  	"    Inserts item before first occurance of beforeItem or to the end of the list if\n"
  	"    beforeItem is not found. Returns self.\n"
  	"    */\n"
  	"    insertBefore := method(item, beforeItem,\n"
  	"        i := self indexOf(beforeItem)\n"
  	"        if(i, self atInsert(i, item), self append(item))\n"
  	"        self\n"
  	"    )\n"
  	"\n"
  	"    /*doc List insertAt(item, index)\n"
  	"    Inserts item at the specified index. Raises an exception if the index is\n"
  	"    out of bounds. Returns self.\n"
  	"    */\n"
  	"    insertAt := method(item, index, self atInsert(index, item))\n"
  	"\n"
  	"    max := method(\n"
  	"        m := call argAt(0)\n"
  	"        obj := self first\n"
  	"        self foreach(o,\n"
  	"            v1 := if(m, o doMessage(m, call sender), o)\n"
  	"            v2 := if(m, obj doMessage(m, call sender), obj)\n"
  	"            if(v1 > v2, obj := o)\n"
  	"        )\n"
  	"        obj\n"
  	"    )\n"
  	"\n"
  	"    min := method(\n"
  	"        m := call argAt(0)\n"
  	"        obj := self first\n"
  	"        self foreach(o,\n"
  	"            v1 := if(m, o doMessage(m, call sender), o)\n"
  	"            v2 := if(m, obj doMessage(m, call sender), obj)\n"
  	"            if(v1 < v2, obj := o)\n"
  	"        )\n"
  	"        obj\n"
  	"    )\n"
  	"\n"
  	"    /*doc List flatten\n"
  	"    Creates a new list, with all contained lists flattened into the new list. For example:\n"
  	"<code>\n"
  	"list(1,2,list(3,4,list(5))) flatten\n"
  	"==> list(1, 2, 3, 4, 5)\n"
  	"</code>\n"
  	"    */\n"
  	"    List flatten := method(\n"
  	"        l := List clone\n"
  	"        self foreach(v,\n"
  	"            if(getSlot(\"v\") isKindOf(List),\n"
  	"                l appendSeq(getSlot(\"v\") flatten)\n"
  	"            ,\n"
  	"                l append(getSlot(\"v\")))\n"
  	"        )\n"
  	"        l\n"
  	"    )\n"
  	"\n"
  	"    //doc List cursor Returns a ListCursor for the receiver.\n"
  	"    cursor := method(ListCursor clone setCollection(self))\n"
  	"\n"
  	"    //doc List containsAll(list) Returns true the target contains all of the items in the argument list.\n"
  	"    containsAll := method(c, c detect(i, contains(i) not) == nil)\n"
  	"\n"
  	"    //doc List containsAny(list) Returns true the target contains any of the items in the argument list.\n"
  	"    containsAny := method(c, c detect(i, contains(i)) != nil)\n"
  	"\n"
  	"    //doc List intersect(list) Returns a new list containing the common values from the target and argument lists.\n"
  	"    intersect := method(c, c select(i, contains(i)))\n"
  	"\n"
  	"    //doc List difference(list) Returns a new list containing items from the target list which aren't in the argument list.\n"
  	"    difference := method(c, select(i, c contains(i) not))\n"
  	"\n"
  	"    //doc List union(list) Returns a new list containing items from the target and items which are only in the argument list.\n"
  	"    union := method(c, self clone appendSeq(c difference(self)))\n"
  	"\n"
  	"    //doc List unique Returns a new list containing all the values in the target, but no duplicates.\n"
  	"    unique := method(a := list; self foreach(v, a appendIfAbsent(v)); a)\n"
  	"\n"
  	"    /*doc List reduce\n"
  	"    Also known as foldl or inject. Combines values in target starting on the left.\n"
  	"    If no initial value is paseed the head of the list is used. <br />\n"
  	"<pre>\n"
  	"Io> list(1, 2, 3) reduce(+)\n"
  	"==> 6\n"
  	"Io> list(1, 2, 3) reduce(xs, x, xs + x)\n"
  	"==> 6\n"
  	"Io> list(1, 2, 3) reduce(+, -6) # Passing the initial value.\n"
  	"==> 0\n"
  	"Io> list(1, 2, 3) reduce(xs, x, xs + x, -6)\n"
  	"==> 0\n"
  	"</pre>\n"
  	"*/\n"
  	"    reduce := method(\n"
  	"        argCount := call argCount\n"
  	"\n"
  	"        if(argCount == 0, Exception raise(\"missing argument\"))\n"
  	"        # Checking for the initial value, if it's not present, the\n"
  	"        # head of the list is used.\n"
  	"        if(argCount == 2 or argCount == 4,\n"
  	"            target := self\n"
  	"            accumulator := call sender doMessage(\n"
  	"                call argAt(argCount - 1)\n"
  	"            )\n"
  	"        ,\n"
  	"            target := slice(1)\n"
  	"            accumulator := first\n"
  	"        )\n"
  	"\n"
  	"        if(argCount <= 2,\n"
  	"            args := list(nil)\n"
  	"            method := call argAt(0) name\n"
  	"            target foreach(x,\n"
  	"                accumulator = accumulator performWithArgList(\n"
  	"                    method, args atPut(0, x)\n"
  	"                )\n"
  	"            )\n"
  	"        ,\n"
  	"            aName := call argAt(0) name # Accumulator.\n"
  	"            bName := call argAt(1) name # Item.\n"
  	"            body := call argAt(2)\n"
  	"            # Creating a context, in which the body would be executed in.\n"
  	"            context := Object clone prependProto(call sender)\n"
  	"            # Note: this is needed for the Object_forwardLocals() method to\n"
  	"            # work correctly. See IoObject.c:870.\n"
  	"            if(call sender hasLocalSlot(\"self\"),\n"
  	"                context setSlot(\"self\", call sender self)\n"
  	"            )\n"
  	"            target foreach(x,\n"
  	"                context setSlot(aName, accumulator)\n"
  	"                context setSlot(bName, x)\n"
  	"                accumulator = context doMessage(body)\n"
  	"            )\n"
  	"        )\n"
  	"        accumulator\n"
  	"    )\n"
  	"\n"
  	"    /*doc List reverseReduce\n"
  	"    Also known as foldr or inject. Combines values in target starting on the right.\n"
  	"    If no initial value is paseed the head of the list is used. See List reverse for examples.\n"
  	"    */\n"
  	"    reverseReduce := method(\n"
  	"        # An alternative approach is to create a generic method\n"
  	"        # which will take an extra argument formeth, and two\n"
  	"        # wrappers passing foreach and foreachReversed to the\n"
  	"        # generic method.\n"
  	"        call delegateToMethod(self reverse, \"reduce\")\n"
  	"    )\n"
  	"\n"
  	"    //doc List uniqueCount Returns a list of list(value, count) for each unique value in self.\n"
  	"    uniqueCount := method(self unique map(item, list(item, self select(== item) size)))\n"
  	"\n"
  	"    exSlice := getSlot(\"slice\")\n"
  	"\n"
  	"/*doc List groupBy\n"
  	"    Group items in a List by common expression value and return them aggregated in a Map.\n"
  	"    <em>Note</em>: asJson is used because Map doesn't have asString method implemented.\n"
  	"<pre>\n"
  	"Io> list(\"a\", \"b\", \"cd\") groupBy(size) asJson\n"
  	"==> {\"2\":[\"cd\"],\"1\":[\"a\",\"b\"]}\n"
  	"Io> list(\"a\", \"b\", \"cd\") groupBy(v, v containsSeq(\"c\")) asJson\n"
  	"==> {\"false\":[\"a\",\"b\"],\"true\":[\"cd\"]}\n"
  	"Io> list(\"a\", \"b\", \"cd\") groupBy(i, v, i == 1) asJson\n"
  	"==> {\"false\":[\"a\",\"cd\"],\"true\":[\"b\"]}\n"
  	"</pre>\n"
  	"*/\n"
  	"    groupBy := method(\n"
  	"        result  := Map clone\n"
  	"        # Creating a context, in which the body would be executed in.\n"
  	"        context := Object clone prependProto(call sender)\n"
  	"        # Note: this is needed for the Object_forwardLocals() method to\n"
  	"        # work correctly. See IoObject.c:870.\n"
  	"        if(call sender hasLocalSlot(\"self\"),\n"
  	"            context setSlot(\"self\", call sender self)\n"
  	"        )\n"
  	"        argCount := call argCount\n"
  	"\n"
  	"        if(argCount == 0, Exception raise(\"missing argument\"))\n"
  	"        if(argCount == 1) then(\n"
  	"            body := call argAt(0)\n"
  	"            self foreach(value,\n"
  	"                key := getSlot(\"value\") doMessage(body, context) asString\n"
  	"                result atIfAbsentPut(key, list())\n"
  	"                result at(key) append(getSlot(\"value\"))\n"
  	"            )\n"
  	"        ) elseif(argCount == 2) then(\n"
  	"            eName := call argAt(0) name # Element.\n"
  	"            body  := call argAt(1)\n"
  	"            self foreach(value,\n"
  	"                context setSlot(eName, getSlot(\"value\"))\n"
  	"\n"
  	"                key := context doMessage(body) asString\n"
  	"                result atIfAbsentPut(key, list())\n"
  	"                result at(key) append(getSlot(\"value\"))\n"
  	"            )\n"
  	"        ) else(\n"
  	"            iName := call argAt(0) name # Index.\n"
  	"            eName := call argAt(1) name # Element.\n"
  	"            body  := call argAt(2)\n"
  	"\n"
  	"            self foreach(idx, value,\n"
  	"                context setSlot(iName, idx)\n"
  	"                context setSlot(eName, getSlot(\"value\"))\n"
  	"\n"
  	"                key := context doMessage(body) asString\n"
  	"                result atIfAbsentPut(key, list())\n"
  	"                result at(key) append(getSlot(\"value\"))\n"
  	"            )\n"
  	"        )\n"
  	"\n"
  	"        result\n"
  	"    )\n"
  	"\n"
  	"    /*doc List asMessage\n"
  	"    Converts each element in the list to unnamed messages with their cached result\n"
  	"    set to the value of the element (without activating).Returns an unnamed message\n"
  	"    whose arguments map 1:1 with the elements (after being converted to messages themselves).\n"
  	"    */\n"
  	"    asMessage := method(\n"
  	"        m := Message clone\n"
  	"        foreach(elem,\n"
  	"            m setArguments(\n"
  	"                m arguments append(Message clone setCachedResult(getSlot(\"elem\")))\n"
  	"            )\n"
  	"        )\n"
  	"        m\n"
  	"    )\n"
  	"\n"
  	"    asString := method(\"list(\" .. self join(\", \") .. \")\")\n"
  	"    asSimpleString := method(\n"
  	"        result := self slice(0, 30) asString\n"
  	"        if(result size > 40,\n"
  	"            result exSlice(0, 37) .. \"...\"\n"
  	"        ,\n"
  	"            result\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"    //doc List asJson Returns JSON encoded representation of a List.\n"
  	"    asJson := method(\n"
  	"        \"[\" .. self map(asJson) join(\",\") .. \"]\"\n"
  	"    )\n"
  	"\n"
  	"    /*doc List asMap\n"
  	"    The reverse of Map asList: converts a list of lists (key-value pairs) into\n"
  	"    a Map. The first item of each pair list must be a sequence. The second item\n"
  	"    is the value.\n"
  	"    */\n"
  	"    asMap := method(\n"
  	"        m := Map clone\n"
  	"        self foreach(pair, m atPut(pair at(0), pair at(1)))\n"
  	"    )\n"
  	")\n"
  	"\n"
  	"List ListCursor := Object clone do(\n"
  	"    newSlot(\"index\", 0)\n"
  	"    newSlot(\"collection\")\n"
  	"    next := method(index = index + 1; max := (collection size - 1); if(index > max, index = max; false, true))\n"
  	"    previous := method(index = index - 1; if(index < 0, index = 0; false, true))\n"
  	"    value := method(collection at(index))\n"
  	"    insert := method(v, collection atInsert(index, getSlot(\"v\")))\n"
  	"    remove := method(v, collection removeAt(index))\n"
  	")\n"
  	"\n"
  	"# IMPORTANT:\n"
  	"# ----------\n"
  	"# The following methods be removed, because they aren't:\n"
  	"#   * documented,\n"
  	"#   * unittested,\n"
  	"#   * used anywhere else in the code.\n"
  	"#\n"
  	"# Note: probably, List second() and List third() should also be considered\n"
  	"# for removal.\n"
  	"\n"
  	"List do(\n"
  	"    mapFromKey := method(key,\n"
  	"        e := key asMessage\n"
  	"        m := Map clone\n"
  	"        self foreach(v,\n"
  	"            k := getSlot(\"v\") doMessage(e)\n"
  	"            l := m at(k)\n"
  	"            if(l, l append(getSlot(\"v\")), m atPut(k, list(getSlot(\"v\"))))\n"
  	"        )\n"
  	"        m\n"
  	"    )\n"
  	")";

    IoState_rawOn_doCString_withLabel_(self, context, s, "A3_List.io");

	s = "\n"
  	"Call do(\n"
  	"	description := method(\n"
  	"		//doc Call description Returns a description of the receiver as a String.\n"
  	"		m := self message\n"
  	"		s := self target type .. \" \" .. m name\n"
  	"		s alignLeft(36) .. \" \" .. m label lastPathComponent .. \" \" .. m lineNumber\n"
  	"	)\n"
  	"\n"
  	"	delegateTo := method(target, altSender,\n"
  	"		/*doc Call delegateTo(target, altSender)\n"
  	"		Sends the call's message to target (and relays it's stop status).\n"
  	"		The sender is set to altSender, if it is supplied.\n"
  	"		Returns the result of the message.\n"
  	"		*/\n"
  	"		call relayStopStatus(target doMessage(self message clone setNext, altSender ifNilEval(self sender)))\n"
  	"	)\n"
  	"\n"
  	"	delegateToMethod := method(target, methodName,\n"
  	"		/*doc Call delegateToMethod(target, methodName)\n"
  	"		Sends the call's message to target via the method specified by methodName.\n"
  	"		Returns the result of the message.\n"
  	"		*/\n"
  	"		call relayStopStatus(target doMessage(self message clone setNext setName(methodName), self sender))\n"
  	"	)\n"
  	"\n"
  	"	/*doc Call evalArgs\n"
  	"	Returns a list containing the call message arguments evaluated in the context of the sender.\n"
  	"	*/\n"
  	"	evalArgs := method(self message argsEvaluatedIn(sender)) setPassStops(true)\n"
  	"\n"
  	"	//doc Call hasArgs Returns true if the call was passed arguments.\n"
  	"	hasArgs  := method(argCount > 0)\n"
  	"\n"
  	"	//doc Call argCount Returns the number of arguments for the call. Shortcut for \"call message argCount\".\n"
  	"	argCount := method(self message argCount)\n"
  	")\n"
  	"\n"
  	"Message description := method(\n"
  	"	//doc Message description Returns a string containing a short description of the method.\n"
  	"	self name alignLeft(36) .. self label lastPathComponent .. \" \" .. self lineNumber\n"
  	")\n"
  	"\n"
  	"Scheduler := Object clone do(\n"
  	"	//metadoc Scheduler category Core\n"
  	"	//metadoc Scheduler description Io's coroutine scheduler.\n"
  	"\n"
  	"	//doc Scheduler yieldingCoros The List of yielding Coroutine objects.\n"
  	"	//doc Scheduler setYieldingCoros(aListOfCoros) Sets the list of yielding Coroutine objects.\n"
  	"	yieldingCoros ::= List clone\n"
  	"\n"
  	"	//doc Scheduler timers The List of active timers.\n"
  	"	//doc Scheduler setTimers(aListOfTimers) Sets the list of active timers.\n"
  	"	timers ::= List clone\n"
  	"\n"
  	"	//doc Scheduler currentCoroutine Returns the currently running coroutine.\n"
  	"	currentCoroutine := method(Coroutine currentCoroutine)\n"
  	"\n"
  	"	waitForCorosToComplete := method(\n"
  	"		while(yieldingCoros size > 0, yield)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Coroutine do(\n"
  	"	//metadoc Coroutine category Core\n"
  	"	//metadoc Coroutine description Coroutine is an primitive for Io's lightweight cooperative C-stack based threads.\n"
  	"\n"
  	"	/*\n"
  	"	init := method(\n"
  	"		resend\n"
  	"		\"Coroutine init\" println\n"
  	"	)\n"
  	"	*/\n"
  	"	\n"
  	"	//doc Coroutine stackSize Stack size allocated for each new coroutine. Coroutines will automatically chain themselves as need if more stack space is required.\n"
  	"	//doc Coroutine setStackSize(aNumber) Sets the stack size in bytes to allocate for new Coros. Returns self.\n"
  	"	//stackSize ::= 131072 // PPC needs 128k for current parser\n"
  	"	stackSize ::= 131072 // PPC needs 128k for current parser\n"
  	"\n"
  	"	//doc Coroutine exception Returns the current exception or nil if there is none.\n"
  	"	//doc Coroutine setException\n"
  	"	exception ::= nil\n"
  	"\n"
  	"	//doc Coroutine parentCoroutine Returns the parent coroutine this one was chained from or nil if it wasn't chained. When a Coroutine ends, it will attempt to resume it's parent.\n"
  	"\n"
  	"	//doc Coroutine setParentCoroutine(aCoro) Sets the parent coroutine. Returns self.\n"
  	"	parentCoroutine ::= nil\n"
  	"\n"
  	"	//doc Coroutine runTarget The object which the coroutine will send a message to when it starts.\n"
  	"	//doc Coroutine setRunTarget(anObject)\n"
  	"	runTarget ::= nil\n"
  	"\n"
  	"	//doc Coroutine runLocals The locals object in whose context the coroutine will send its run message.\n"
  	"	//doc Coroutine setRunLocals\n"
  	"	runLocals ::= nil\n"
  	"\n"
  	"	//doc Coroutine runMessage The message to send to the runTarget when the coroutine starts.\n"
  	"	//doc Coroutine setRunMessage\n"
  	"	runMessage ::= nil\n"
  	"\n"
  	"	//doc Coroutine result The result set when the coroutine ends.\n"
  	"	//doc Coroutine setResult\n"
  	"	result ::= nil\n"
  	"\n"
  	"	//doc Coroutine label A label slot useful for debugging purposes.\n"
  	"	//doc Coroutine setLabel(aLabel) Sets the comment label for the Coro. Return self.\n"
  	"	label ::= \"\"\n"
  	"\n"
  	"	//doc Coroutine inException Set to true when processing an exception in the coroutine.\n"
  	"	//doc Coroutine setInException(aBool) Set the inException status. Returns self.\n"
  	"	inException ::= false\n"
  	"\n"
  	"\n"
  	"	yieldingCoros ::= Scheduler yieldingCoros\n"
  	"	//doc Coroutine yieldingCoros Reference to Scheduler yieldingCoros.\n"
  	"	//--doc Coroutine setYieldingCoros(aListOfCoros)\n"
  	"\n"
  	"	debugWriteln := nil\n"
  	"	//doc Coroutine debugWriteln See <tt>Object debugWriteln</tt>.\n"
  	"\n"
  	"	label := method(self uniqueId)\n"
  	"	setLabel := method(s, self label = s .. \"_\" .. self uniqueId)\n"
  	"\n"
  	"	showYielding := method(s,\n"
  	"		//doc Coroutine showYielding Prints a list of yielding coroutines to STDOUT.\n"
  	"		writeln(\"   \", label, \" \", s)\n"
  	"		yieldingCoros foreach(v, writeln(\"    \", v uniqueId))\n"
  	"	)\n"
  	"\n"
  	"	isYielding := method(yieldingCoros contains(self))\n"
  	"	//doc Coroutine isYielding Returns true if the receiver is yielding (not paused or running).\n"
  	"\n"
  	"	yield := method(\n"
  	"		/*doc Coroutine yield\n"
  	"		Yields to another coroutine in the yieldingCoros queue.\n"
  	"		Does nothing if yieldingCoros is empty.\n"
  	"		*/\n"
  	"		//showYielding(\"yield\")\n"
  	"		//writeln(\"Coro \", self uniqueId, \" yielding - yieldingCoros = \", yieldingCoros size)\n"
  	"		if(yieldingCoros isEmpty, return)\n"
  	"		yieldingCoros append(self)\n"
  	"		next := yieldingCoros removeFirst\n"
  	"		if(next == self, return)\n"
  	"		//writeln(Scheduler currentCoroutine label, \" yield - \", next label, \" resume\")\n"
  	"		if(next, next resume)\n"
  	"	)\n"
  	"\n"
  	"	resumeLater := method(\n"
  	"		/*doc Coroutine resumeLater\n"
  	"		Promotes receiver to the top of the yieldingCoros queue, but not yielding to it.\n"
  	"		When current coroutine yields, receiver will resume.\n"
  	"		*/\n"
  	"		//waitingOn remove(call sender)\n"
  	"		//if(waitingOn isEmpty,\n"
  	"			yieldingCoros remove(self)\n"
  	"			yieldingCoros atInsert(0, self)\n"
  	"		//)\n"
  	"		//writeln(self label, \" resumeLater\")\n"
  	"	)\n"
  	"\n"
  	"\n"
  	"	pause := method(\n"
  	"		/*doc Coroutine pause\n"
  	"		Removes current coroutine from the yieldingCoros queue and\n"
  	"		yields to another coro. <tt>System exit</tt> is executed if no coros left.\n"
  	"		<br/>\n"
  	"		You can resume a coroutine using either <tt>resume</tt> or <tt>resumeLater</tt> message.\n"
  	"		*/\n"
  	"		yieldingCoros remove(self)\n"
  	"		if(isCurrent,\n"
  	"			next := yieldingCoros removeFirst\n"
  	"			if(next,\n"
  	"				next resume\n"
  	"			,\n"
  	"				//Exception raise(\"Scheduler: nothing left to resume so we are exiting\")\n"
  	"				writeln(\"Scheduler: nothing left to resume so we are exiting\")\n"
  	"				self showStack\n"
  	"				System exit\n"
  	"			)\n"
  	"		,\n"
  	"			yieldingCoros remove(self)\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	//FIXME: these two methods are identical!!\n"
  	"	yieldCurrentAndResumeSelf := method(\n"
  	"		//doc Coroutine yieldCurrentAndResumeSelf Yields to a receiver.\n"
  	"		//showYielding(\"yieldCurrentAndResumeSelf\")\n"
  	"		yieldingCoros remove(self)\n"
  	"		isCurrent ifFalse(resume)\n"
  	"	)\n"
  	"\n"
  	"	//FIXME: these two methods are identical!!\n"
  	"	pauseCurrentAndResumeSelf := method(\n"
  	"		//doc Coroutine pauseCurrentAndResumeSelf Pauses current coroutine and yields to a receiver.\n"
  	"		//showYielding(\"pauseCurrentAndResumeSelf\")\n"
  	"		yieldingCoros remove(self)\n"
  	"		isCurrent ifFalse(resume)\n"
  	"	)\n"
  	"\n"
  	"	typeId := method(self type .. \"_0x\" .. self uniqueId asString toBase(16))\n"
  	"	//doc Coroutine typeId Returns <type>_<uniqueHexId> string.\n"
  	"\n"
  	"	ignoredCoroutineMethodNames := list(\"setResult\", \"main\", \"pauseCurrentAndResumeSelf\", \"resumeParentCoroutine\", \"raiseException\")\n"
  	"  	//doc Coroutine ignoredCoroutineMethodNames List of methods to ignore when building a <tt>callStack</tt>.\n"
  	"\n"
  	"	callStack := method(\n"
  	"		//doc Coroutine callStack Returns a list of Call objects.\n"
  	"		stack := ioStack\n"
  	"		stack selectInPlace(v, Object argIsCall(getSlot(\"v\"))) reverseInPlace\n"
  	"		stack selectInPlace(v,\n"
  	"			(v target type == \"Coroutine\" and \\\n"
  	"             self ignoredCoroutineMethodNames contains(v message name)) not\n"
  	"		)\n"
  	"		stack foreach(i, v, if(v target type == \"Importer\" and v message name == \"import\", stack sliceInPlace(i+1); break) )\n"
  	"		stack := stack unique\n"
  	"		//if(parentCoroutine and parentCoroutine != self, stack appendSeq(parentCoroutine callStack))\n"
  	"		stack\n"
  	"	)\n"
  	"\n"
  	"	backTraceString := method(\n"
  	"	    //doc Coroutine backTraceString Returns a formatted callStack output along with exception info (if any). In case of CGI script, wraps output with &lt;code&gt; tag.\n"
  	"		if(Coroutine inException,\n"
  	"			writeln(\"\\n\", exception type, \": \", exception error, \"\\n\\n\")\n"
  	"			writeln(\"Coroutine Exception loop detected\");\n"
  	"			System exit\n"
  	"		)\n"
  	"		Coroutine setInException(true)\n"
  	"		buf := Sequence clone\n"
  	"\n"
  	"		//writeln(\"backTraceString 1\\n\")\n"
  	"		if(getSlot(\"CGI\") != nil and CGI isInWebScript, buf appendSeq(\"<code>\"))\n"
  	"\n"
  	"		if(exception, buf appendSeq(\"\\n  \", exception type, \": \", exception error, \"\\n\"))\n"
  	"\n"
  	"		//writeln(\"backTraceString 2\\n\")\n"
  	"		if(callStack size > 0) then(\n"
  	"			buf appendSeq(\"  ---------\\n\")\n"
  	"\n"
  	"			if(exception and exception ?caughtMessage,\n"
  	"				buf appendSeq(\"  \", exception caughtMessage description, \"\\n\")\n"
  	"			)\n"
  	"\n"
  	"			frames := callStack\n"
  	"\n"
  	"			if(exception and exception originalCall,\n"
  	"				index := frames indexOf(exception originalCall)\n"
  	"				if(index,\n"
  	"					frames sliceInPlace(index)\n"
  	"				)\n"
  	"			)\n"
  	"\n"
  	"			frames foreach(v,\n"
  	"				buf appendSeq(\"  \", v description, \"\\n\")\n"
  	"			)\n"
  	"			buf appendSeq(\"\\n\")\n"
  	"		) else(\n"
  	"			buf appendSeq(\"  ---------\\n\")\n"
  	"			if(exception and exception caughtMessage,\n"
  	"				m := exception caughtMessage\n"
  	"				buf appendSeq(\"  message '\" .. m name .. \"' in '\" .. m label .. \"' on line \" .. m lineNumber .. \"\\n\")\n"
  	"				buf appendSeq(\"\\n\")\n"
  	"			,\n"
  	"				buf appendSeq(\"  nothing on stack\\n\")\n"
  	"			)\n"
  	"		)\n"
  	"\n"
  	"		Coroutine setInException(false)\n"
  	"		buf\n"
  	"	)\n"
  	"\n"
  	"	showStack := method(\n"
  	"		//doc Coroutine showStack Writes backTraceString to STDOUT.\n"
  	"		write(backTraceString)\n"
  	"	)\n"
  	"\n"
  	"	resumeParentCoroutine := method(\n"
  	"		//doc Coroutine resumeParentCoroutine Pauses current coroutine and resumes parent.\n"
  	"		if(parentCoroutine, parentCoroutine pauseCurrentAndResumeSelf)\n"
  	"	)\n"
  	"\n"
  	"	main := method(\n"
  	"		//doc Coroutine main [Seems to be obsolete!] Executes runMessage, resumes parent coroutine.\n"
  	"		setResult(self getSlot(\"runTarget\") doMessage(runMessage, self getSlot(\"runLocals\")))\n"
  	"		resumeParentCoroutine\n"
  	"		pause\n"
  	"	)\n"
  	"\n"
  	"	raiseException := method(e,\n"
  	"		//doc Coroutine raiseException Sets exception in the receiver and resumes parent coroutine.\n"
  	"		self setException(e)\n"
  	"		resumeParentCoroutine\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Object wait := method(s,\n"
  	"	/*doc Object wait(s)\n"
  	"	Pauses current coroutine for at least <tt>s</tt> seconds.\n"
  	"	<br/>\n"
  	"	Note: current coroutine may wait much longer than designated number of seconds\n"
  	"	depending on circumstances.\n"
  	"	*/\n"
  	"\n"
  	"	//writeln(\"Scheduler yieldingCoros size = \", Scheduler yieldingCoros size)\n"
  	"	if(Scheduler yieldingCoros isEmpty,\n"
  	"		//writeln(\"System sleep\")\n"
  	"		System sleep(s)\n"
  	"	,\n"
  	"		//writeln(\"Object wait\")\n"
  	"		endDate := Date clone now + Duration clone setSeconds(s)\n"
  	"		loop(endDate isPast ifTrue(break); yield)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Message do(\n"
  	"	codeOfLength := method(length,\n"
  	"		/*doc Message codeOfLength(n)\n"
  	"		Same as <tt>Message code</tt>, but returns first <tt>n</tt> characters only.\n"
  	"		*/\n"
  	"		c := self code\n"
  	"		if (c size < length, c, c exclusiveSlice(0, length) .. \"...\") asMutable replaceSeq(\"\\n\", \";\")\n"
  	"	)\n"
  	"\n"
  	"	asStackEntry := method(\n"
  	"		//doc Message asStackEntry Returns a string containing message name, file and line.\n"
  	"		label := label lastPathComponent fileName\n"
  	"		label alignLeft(19) .. lineNumber asString alignLeft(7) .. name\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"	try := method(\n"
  	"		/*doc Object try(code)\n"
  	"		Executes particular code in a new coroutine.\n"
  	"		Returns exception or nil if no exception is caught.\n"
  	"		<br/>\n"
  	"		See also documentation for Exception catch and pass.\n"
  	"		*/\n"
  	"		coro := Coroutine clone\n"
  	"		coro setParentCoroutine(Scheduler currentCoroutine)\n"
  	"		coro setRunTarget(call sender)\n"
  	"		coro setRunLocals(call sender)\n"
  	"		coro setRunMessage(call argAt(0))\n"
  	"		coro run\n"
  	"		if(coro exception, coro exception, nil)\n"
  	"	)\n"
  	"\n"
  	"\n"
  	"	coroFor := method(\n"
  	"		/*doc Object coroFor(code)\n"
  	"		Returns a new coro to be run in a context of sender.\n"
  	"		*/\n"
  	"		coro := Coroutine clone\n"
  	"		coro setRunTarget(call sender)\n"
  	"		coro setRunLocals(call sender)\n"
  	"		coro setRunMessage(call argAt(0))\n"
  	"		coro\n"
  	"	)\n"
  	"\n"
  	"	coroDo := method(\n"
  	"		/*doc Object coroDo(code)\n"
  	"		Creates a new coro to be run in a context of sender and yields to it.\n"
  	"		Returns a coro.\n"
  	"		*/\n"
  	"		coro := Coroutine clone\n"
  	"		coro setRunTarget(call sender)\n"
  	"		coro setRunLocals(call sender)\n"
  	"		coro setRunMessage(call argAt(0))\n"
  	"		Coroutine yieldingCoros atInsert(0, Scheduler currentCoroutine)\n"
  	"		coro run\n"
  	"		coro\n"
  	"	)\n"
  	"\n"
  	"\n"
  	"	coroDoLater := method(\n"
  	"		/*doc Object coroDoLater(code)\n"
  	"		Returns a new coro to be run in a context of sender.\n"
  	"		New coro is moved to the top of the yieldingCoros queue to be executed\n"
  	"		when current coro yields.\n"
  	"		<br/>\n"
  	"		Note: run target is <tt>self</tt> (i.e. receiver), not <tt>call sender</tt> as in coroDo.\n"
  	"		*/\n"
  	"		coro := Coroutine clone\n"
  	"		coro setRunTarget(self)\n"
  	"		coro setRunLocals(call sender)\n"
  	"		coro setRunMessage(call argAt(0))\n"
  	"		Coroutine yieldingCoros atInsert(0, coro)\n"
  	"		coro\n"
  	"	)\n"
  	"\n"
  	"\n"
  	"	coroWith := method(\n"
  	"		//doc Object coroWith(code) Returns a new coro to be run in a context of receiver.\n"
  	"		coro := Coroutine clone\n"
  	"		coro setRunTarget(self)\n"
  	"		coro setRunLocals(call sender)\n"
  	"		coro setRunMessage(call argAt(0))\n"
  	"		coro\n"
  	"	)\n"
  	"\n"
  	"	currentCoro := method(\n"
  	"		//doc Object currentCoro Returns the currently running coroutine.\n"
  	"		Coroutine currentCoroutine\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"nil do(\n"
  	"	catch := nil\n"
  	"	//doc nil catch Does nothing, returns nil. See <tt>Exception catch</tt>.\n"
  	"\n"
  	"	pass := nil\n"
  	"	//doc nil pass Does nothing, returns nil. See <tt>Exception pass</tt>.\n"
  	")\n"
  	"\n"
  	"Protos Exception do(\n"
  	"	//metadoc Exception category Core\n"
  	"	/*metadoc Exception description\n"
  	"The Exception proto is used for raising exceptions and instances are used to hold rexception related info.\n"
  	"\n"
  	"<p><b>Raise</b><p>\n"
  	"\n"
  	"An exception can be raised by calling raise() on an exception proto.\n"
  	"Exception raise(\"generic foo exception\")\n"
  	"\n"
  	"<p><b>Try and Catch</b><p>\n"
  	"\n"
  	"To catch an exception, the try() method of the Object proto is used. try() will catch any exceptions that occur within it and return the caught exception or nil if no exception is caught.\n"
  	"\n"
  	"<pre>\n"
  	"e := try(<doMessage>)\n"
  	"</pre>\n"
  	"\n"
  	"To catch a particular exception, the Exception catch() method can be used. Example:\n"
  	"\n"
  	"<pre>\n"
  	"e := try(\n"
  	"    // ...\n"
  	")\n"
  	"\n"
  	"e catch(Exception,\n"
  	"    writeln(e coroutine backtraceString)\n"
  	")\n"
  	"</pre>\n"
  	"\n"
  	"The first argument to catch indicates which types of exceptions will be caught. catch() returns the exception if it doesn't match and nil if it does.\n"
  	"\n"
  	"<p><b>Pass</b><p>\n"
  	"\n"
  	"To re-raise an exception caught by try(), use the pass method. This is useful to pass the exception up to the next outer exception handler, usually after all catches failed to match the type of the current exception:\n"
  	"<pre>\n"
  	"e := try(\n"
  	"    // ...\n"
  	")\n"
  	"\n"
  	"e catch(Error,\n"
  	"    // ...\n"
  	") catch(Exception,\n"
  	"    // ...\n"
  	") pass\n"
  	"</pre>\n"
  	"\n"
  	"<p><b>Custom Exceptions</b><p>\n"
  	"\n"
  	"Custom exception types can be implemented by simply cloning an existing Exception type:\n"
  	"<pre>\n"
  	"MyErrorType := Error clone\n"
  	"</pre>\n"
  	"\n"
  	"*/\n"
  	"\n"
  	"	type := \"Exception\"\n"
  	"	newSlot(\"error\")\n"
  	"	//doc Exception error Returns the error description string.\n"
  	"\n"
  	"	newSlot(\"coroutine\")\n"
  	"	//doc Exception error Returns the coroutine that the exception occurred in.\n"
  	"\n"
  	"	newSlot(\"caughtMessage\")\n"
  	"	//doc Exception caughtMessage Returns the message object associated with the exception.\n"
  	"\n"
  	"	newSlot(\"nestedException\")\n"
  	"	//doc Exception nestedException Returns the nestedException if there is one.\n"
  	"\n"
  	"	newSlot(\"originalCall\")\n"
  	"	//doc Exception originalCall Returns the call object associated with the exception.\n"
  	"\n"
  	"	raise := method(error, nestedException,\n"
  	"		//doc Exception raise(error, optionalNestedException) Raise an exception with the specified error message.\n"
  	"		coro := Scheduler currentCoroutine\n"
  	"		coro raiseException(self clone setError(error) setCoroutine(coro) setNestedException(nestedException))\n"
  	"	)\n"
  	"\n"
  	"	raiseFrom := method(originalCall, error, nestedException,\n"
  	"		coro := Scheduler currentCoroutine\n"
  	"		coro raiseException(self clone setError(error) setCoroutine(coro) setNestedException(nestedException) setOriginalCall(originalCall))\n"
  	"	)\n"
  	"\n"
  	"	catch := method(exceptionProto,\n"
  	"		//doc Exception catch(exceptionProto) Catch an exception with the specified exception prototype.\n"
  	"		if (self isKindOf(exceptionProto), call evalArgAt(1); nil, self)\n"
  	"	)\n"
  	"\n"
  	"	pass := method(\n"
  	"		//doc Exception pass Pass the exception up the stack.\n"
  	"		Scheduler currentCoroutine raiseException(self)\n"
  	"	)\n"
  	"\n"
  	"	showStack := method(\n"
  	"		//doc Exception showStack Print the exception and related stack.\n"
  	"		coroutine showStack\n"
  	"		if(nestedException,\n"
  	"				writeln(\"Nested Exception: '\", nestedException,  \"'\")\n"
  	"				nestedException showStack\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"System userInterruptHandler := method(\n"
  	"	writeln(\"\\nStack trace:\\n\")\n"
  	"	Scheduler currentCoroutine showStack\n"
  	"	exit\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "A4_Exception.io");

	s = "\n"
  	"Notifier := Object clone do(\n"
  	"	addListener := method(listener,\n"
  	"		if(self getSlot(\"listeners\") == nil, self listeners := List clone)\n"
  	"		listeners append(listener);\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	removeListener := method(obj,\n"
  	"		if(?listeners, listeners remove(obj))\n"
  	"	)\n"
  	"\n"
  	"	notifyListeners := method(\n"
  	"		if(?listeners,\n"
  	"			listeners foreach(l,\n"
  	"				if(l hasSlot(call argAt(0) name),\n"
  	"					stopStatus(l doMessage(call argAt(0), call sender))\n"
  	"				)\n"
  	"			)\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"FutureProxy := Object clone do(\n"
  	"	with := method(future,\n"
  	"		p := self clone\n"
  	"		p _future := future\n"
  	"		p forward := self getSlot(\"_forward\")\n"
  	"		p _become := self getSlot(\"become\")\n"
  	"		//p xyz := method(_future writeln(\"XYZ!\"))\n"
  	"		p type := \"FutureProxy\"\n"
  	"		p removeAllProtos\n"
  	"		p\n"
  	"	)\n"
  	"\n"
  	"	_forward := method(\n"
  	"		//_future writeln(\"FutureProxy forward \", call message)\n"
  	"		_future waitOnResult\n"
  	"		self doMessage(call message, call sender)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Future := Object clone do(\n"
  	"	newSlot(\"runTarget\")\n"
  	"	newSlot(\"runMessage\")\n"
  	"	newSlot(\"waitingCoros\")\n"
  	"\n"
  	"	futureProxy := method(\n"
  	"		self waitingCoros := List clone\n"
  	"		self proxy := FutureProxy with(self)\n"
  	"		proxy\n"
  	"	)\n"
  	"\n"
  	"	setResult := method(r,\n"
  	"		if(self hasSlot(\"proxy\"),\n"
  	"			proxy _become(getSlot(\"r\"))\n"
  	"			if(waitingCoros, waitingCoros foreach(resumeLater))\n"
  	"			//notifyListeners(futureReady(self))\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	waitOnResult := method(\n"
  	"		waitingCoros append(Scheduler currentCoroutine)\n"
  	"		Scheduler currentCoroutine pause\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"/*\n"
  	"Object do(\n"
  	"	actorIsRunning := method(\n"
  	"		//writeln(\"self hasLocalSlot(actorCoroutine) = \", self hasLocalSlot(\"actorCoroutine\"))\n"
  	"		if(self hasLocalSlot(\"actorCoroutine\"),\n"
  	"			writeln(\"actorQueue size = \", actorQueue size)\n"
  	"			writeln(\"Coroutine yieldingCoros contains(actorCoroutine) = \", Coroutine yieldingCoros contains(actorCoroutine))\n"
  	"			writeln(\"Coroutine currentCoroutine == actorCoroutine = \", Coroutine currentCoroutine == actorCoroutine)\n"
  	"		)\n"
  	"\n"
  	"		self hasLocalSlot(\"actorCoroutine\") and(actorQueue size > 0) and(\n"
  	"			Coroutine yieldingCoros contains(actorCoroutine) or(Coroutine currentCoroutine == actorCoroutine)\n"
  	"		)\n"
  	"	)\n"
  	"	actorIsPaused := method(self hasLocalSlot(\"actorCoroutine\") and(actorQueue size > 0))\n"
  	"	actorPause := method(if(actorIsPaused, actorCoroutine pause))\n"
  	"	actorResume := method(if(actorIsPaused, actorCoroutine resumeLater))\n"
  	")\n"
  	"*/\n"
  	"\n"
  	"Object do(\n"
  	"	/*doc Object yield\n"
  	"	Yields to another coroutine. Does nothing if yieldingCoros queue is empty.\n"
  	"	<br/>\n"
  	"	See Coroutine documentation for more details.\n"
  	"	*/\n"
  	"	yield := method(Coroutine currentCoroutine yield)\n"
  	"	\n"
  	"	/*doc Object pause\n"
  	"	Removes current coroutine from the yieldingCoros queue and\n"
  	"	yields to another coro. Exits if no coros left.\n"
  	"	<br/>\n"
  	"	See Coroutine documentation for more details.\n"
  	"	*/\n"
  	"	pause := method(Coroutine currentCoroutine pause)\n"
  	"\n"
  	"  //doc Object actorRun Starts actor mode if not started already. Basically, sets actorProcessQueue for later execution.\n"
  	"	actorRun := method(\n"
  	"		if(self hasLocalSlot(\"actorCoroutine\"),\n"
  	"			if(actorQueue size == 0, self actorCoroutine resumeLater)\n"
  	"		,\n"
  	"			self actorQueue := List clone\n"
  	"			// need to yield in coroDo to allow future to be added to queue\n"
  	"			//self actorCoroutine := self coroDo(yield; actorProcessQueue) // coroDo refs stack!\n"
  	"			self actorCoroutine := Coroutine clone //setStackSize(20000)\n"
  	"			actorCoroutine setRunTarget(self)\n"
  	"			actorCoroutine setRunLocals(self)\n"
  	"			actorCoroutine setRunMessage(message(actorProcessQueue))\n"
  	"			Coroutine yieldingCoros atInsert(0, actorCoroutine)\n"
  	"			//Coroutine yieldingCoros append(actorCoroutine)\n"
  	"		)\n"
  	"	)\n"
  	"  \n"
  	"  //doc Object actorProcessQueue Processes each message in a queue, yielding between each message.\n"
  	"\n"
  	"	actorProcessQueue := method(\n"
  	"		//writeln(self type, \"_\", self uniqueId, \" actorProcessQueue\")\n"
  	"\n"
  	"		/*\n"
  	"		if(Coroutine currentCoroutine isIdenticalTo(self actorCoroutine) not,\n"
  	"			writeln(\"actorProcessQueue called from coro \", Coroutine currentCoroutine uniqueId, \" instead of \", actorCoroutine uniqueId)\n"
  	"			System exit\n"
  	"		)\n"
  	"		*/\n"
  	"\n"
  	"		loop(\n"
  	"			while(future := actorQueue first,\n"
  	"				e := try(\n"
  	"					future setResult(self doMessage(future runMessage))\n"
  	"					//stopStatus(future setResult(self doMessage(future runMessage)))\n"
  	"				)\n"
  	"				actorQueue removeFirst\n"
  	"				if(e, handleActorException(e))\n"
  	"				if(actorQueue first, yield)\n"
  	"			)\n"
  	"\n"
  	"			/*\n"
  	"			if(Coroutine currentCoroutine isIdenticalTo(self actorCoroutine) not,\n"
  	"				writeln(\"actorProcessQueue1 called from coro \", Coroutine currentCoroutine uniqueId, \" instead of \", self actorCoroutine uniqueId)\n"
  	"				System exit\n"
  	"			)\n"
  	"			*/\n"
  	"			self actorCoroutine pause\n"
  	"		)\n"
  	"	)\n"
  	"	\n"
  	"	/*doc Object handleActorException(exception)\n"
  	"	Callback for handling exceptions during asynchronous message processing.\n"
  	"	<br/>\n"
  	"	Default value: method(e, e showStack)\n"
  	"	*/\n"
  	"	handleActorException := method(e, e showStack)\n"
  	"    \n"
  	"	/*doc Object @\n"
  	"	Sends asynchronous message to an object, returns a FutureProxy.\n"
  	"	<br/>\n"
  	"	Caller coroutine is paused when proxy is accessed (i.e. message is sent)\n"
  	"	till result is ready. Proxy will become an actual result when it is ready.\n"
  	"	<br/>\n"
  	"	See IoGuide for more information.\n"
  	"	<br/>\n"
  	"	Usage: obj @someMethod(a, b, c)\n"
  	"	*/\n"
  	"	setSlot(\"@\", method(\n"
  	"		//writeln(\"@ \", call argAt(0))\n"
  	"		m := call argAt(0) asMessageWithEvaluatedArgs(call sender)\n"
  	"		f := Future clone setRunTarget(self) setRunMessage(m)\n"
  	"		self actorRun\n"
  	"		self actorQueue append(f)\n"
  	"		f futureProxy\n"
  	"	))\n"
  	"	\n"
  	"	futureSend := getSlot(\"@\")\n"
  	"  \n"
  	"	/*doc Object @@\n"
  	"	Same as Object @, but returns nil instead of FutureProxy.\n"
  	"	<br/>\n"
  	"	Might be useful in a command line or as a last expression in a block/method when\n"
  	"	you don't want to return a future.\n"
  	"	*/\n"
  	"	setSlot(\"@@\", method(\n"
  	"		//writeln(self type , \"_\", self uniqueId, \" @@\", call argAt(0)) //, \" \", call argAt(0) label)\n"
  	"		m := call argAt(0) asMessageWithEvaluatedArgs(call sender)\n"
  	"		f := Future clone setRunTarget(self) setRunMessage(m)\n"
  	"		self actorRun\n"
  	"		self actorQueue append(f)\n"
  	"		nil\n"
  	"	))\n"
  	"\n"
  	"	asyncSend := getSlot(\"@@\")\n"
  	")\n"
  	"\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "Actor.io");

	s = "Addon := Object clone do(\n"
  	"	//doc Addon rootPath Returns the rootPath of the addon's folder.\n"
  	"	//doc Addon setRootPath(aSequence) Sets rootPath of the addon's folder. Returns self.\n"
  	"	newSlot(\"rootPath\")\n"
  	"\n"
  	"	//doc Addon name Returns the name of the addon.\n"
  	"	//doc Addon setName(aSequence) Sets the name of the addon. Returns self.\n"
  	"	newSlot(\"name\")\n"
  	"\n"
  	"	//doc Addon platform Implemented as method(System platform asLowercase).\n"
  	"	platform := System platform asLowercase\n"
  	"\n"
  	"	//doc Addon dllSuffix Returns the platform specific dll suffix.\n"
  	"	dllSuffix := method(\n"
  	"        list(\"cygwin\", \"mingw\", \"windows\") detect(dllPlatform,\n"
  	"            self platform containsSeq(dllPlatform)\n"
  	"        ) ifNonNil(return(\"dll\"))\n"
  	"\n"
  	"        if(platform == \"darwin\", \"dylib\", \"so\")\n"
  	"	)\n"
  	"\n"
  	"	//doc Addon dllName Return the name of the dll for the addon.\n"
  	"	dllName := method(\"libIo\" .. name .. \".\" .. dllSuffix)\n"
  	"\n"
  	"	//doc Addon addonPath Implemented as Path with(rootPath, name).\n"
  	"	addonPath := method(Path with(rootPath, name))\n"
  	"\n"
  	"	//doc Addon dllPath Returns the path to the dll for the addon. Note: not all addons have dlls - some just contain io files.\n"
  	"	dllPath := method(Path with(addonPath, \"_build/dll\", dllName))\n"
  	"\n"
  	"	//doc Addon sourcePath Returns the path of the source folder for the addon.\n"
  	"	sourcePath := method(Path with(addonPath, \"source\"))\n"
  	"\n"
  	" 	ioFilesPath := method(Path with(addonPath, \"io\"))\n"
  	"\n"
  	"	//doc Addon ioFiles Return list of io File objects for the io files in the io folder of the addon.\n"
  	"	ioFiles := method(\n"
  	"		d := Directory with(ioFilesPath)\n"
  	"		if(d exists not, return list())\n"
  	"		files := d files select(path endsWithSeq(\".io\"))\n"
  	"		files map(name) sort map(name, d fileNamed(name))\n"
  	"	)\n"
  	"\n"
  	"	//doc Addon dependencies Returns the list of dependencies from the addon's depends file.\n"
  	"	dependencies := method(\n"
  	"		File with(Path with(addonPath, \"depends\")) contents split(\" \")\n"
  	"	)\n"
  	"\n"
  	"	//doc Addon loadDependencies Loads the addon's dependencies. Called from the load method.\n"
  	"	loadDependencies := method(\n"
  	"		//writeln(name, \" depends on \", dependencies)\n"
  	"		dependencies foreach(d,\n"
  	"			if(Lobby getSlot(d) == nil,\n"
  	"				//writeln(\"loading dependency \", d)\n"
  	"				if(AddonLoader hasAddonNamed(d)) then(\n"
  	"				    AddonLoader loadAddonNamed(d)\n"
  	"				) else(\n"
  	"				    Exception raise(\"Failed to load Addon \" .. name .. \" - Addon \" .. name .. \" depends on Addon \" .. d .. \" but Addon \" .. d .. \" cannot be found.\")\n"
  	"				)\n"
  	"			)\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	//doc Addon load Loads the addon.\n"
  	"	load := method(\n"
  	"		//writeln(\"ioFilesPath = \", ioFilesPath)\n"
  	"		Importer addSearchPath(ioFilesPath) // to avoid loops when a addon file refs another before it's loaded\n"
  	"			\n"
  	"		loadDependencies\n"
  	"		context := Object clone\n"
  	"		Protos Addons setSlot(name, context)\n"
  	"		Protos appendProto(context)\n"
  	"		//writeln(dllPath)\n"
  	"		if(File with(dllPath) exists,\n"
  	"			DynLib clone setPath(dllPath) open call(\"Io\" .. name .. \"Init\", context)\n"
  	"		,\n"
  	"			// check for C files, if found then addon didn't compile\n"
  	"			if(Directory with(sourcePath) files size > 1,\n"
  	"				Exception raise(\"Failed to load Addon \" .. name .. \" - it appears that the addon exists but was not compiled. You might try running 'make \" .. name .. \"' in the Io source folder.\")\n"
  	"			)\n"
  	"		)\n"
  	"		//ioFiles foreach(f, writeln(\"loading \", f path))\n"
  	"		ioFiles foreach(file, context doFile(file path))\n"
  	"		Importer removeSearchPath(ioFilesPath)\n"
  	"		Lobby getSlot(name)\n"
  	"	)\n"
  	"\n"
  	"	//doc Addon exists Returns true if the addonPath exists, false otherwise.\n"
  	"	exists := method(Directory with(addonPath) exists)\n"
  	"\n"
  	"	//doc Addon addonProtos Returns names of protos defined in the addon from the addon's protos file.\n"
  	"	addonProtos := method(\n"
  	"		f := File with(Path with(addonPath, \"protos\"))\n"
  	"		if(f exists, f contents split, list())\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"AddonLoader := Object clone do(\n"
  	"	//doc Addon searchPaths Returns the list of paths to search for addons.\n"
  	"	searchPaths := list(\"io/addons\", System installPrefix .. \"/lib/io/addons\")\n"
  	"\n"
  	"	//doc Addon appendSearchPath(aSequence) Appends the argument to the list of search paths.\n"
  	"	appendSearchPath := method(p, searchPaths appendIfAbsent(p); self)\n"
  	"\n"
  	"	//doc Addon addons Looks for all addons which can be found and returns them as a list of Addon objects. Caches the result the first time it is called.\n"
  	"	addons := method(\n"
  	"		searchFolders := searchPaths map(path, Directory with(path)) select(exists)\n"
  	"		addonFolders := searchFolders map(directories) flatten //select(isAccessible) select(v, v fileNames contains(\"protos\") or v fileNames contains(\"build.io\"))\n"
  	"		//writeln(\"addonFolders = \", addonFolders map\n"
  	"		self addons := addonFolders map(f, Addon clone setRootPath(f path pathComponent) setName(f path lastPathComponent))\n"
  	"		addons\n"
  	"	)\n"
  	"\n"
  	"	//doc Addon addonFor(aName) Returns the Addon with the given name if it can be found or nil otherwise.\n"
  	"	addonFor := method(name,\n"
  	"		r := addons detect(name == name)\n"
  	"		if(r, return r)\n"
  	"		r := addons detect(addonProtos contains(name))\n"
  	"		r\n"
  	"	)\n"
  	"\n"
  	"	//doc Addon hasAddonNamed(aName) Returns true if the named addon can be found, false otherwise.\n"
  	"	hasAddonNamed := method(name, addonFor(name) != nil)\n"
  	"\n"
  	"	//doc Addon loadAddonNamed(aName) Loads the Addon with the given name if it can be found or nil otherwise.\n"
  	"	loadAddonNamed := method(name,\n"
  	"		addon := addonFor(name)\n"
  	"		if(addon, addon load, nil)\n"
  	"		Lobby getSlot(name)\n"
  	"	)\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "AddonLoader.io");

	s = "\n"
  	"Vector := Sequence clone setItemType(\"float32\") setEncoding(\"number\")\n"
  	"vector := method(v := Vector clone; call evalArgs foreach(n, v append(n)); v)\n"
  	"\n"
  	"\n"
  	"/*\n"
  	"Object moveSlotToObject := method(slotName, target,\n"
  	"	v := self getSlot(slotName)\n"
  	"	self removeSlot(slotName)\n"
  	"	target setSlot(slotName, getSlot(\"v\"))\n"
  	"	writeln(self type, \" removeSlot(\\\"\", slotName, \"\\\")\")\n"
  	")\n"
  	"\n"
  	"\n"
  	"list(\"*\", \"*=\", \"+\", \"+=\", \"-\", \"-=\", \"..\", \"/\", \"/=\", \"<\", \n"
  	"\"<=\", \">\", \">=\", \"Max\", \"Min\", \"abs\", \"acos\", \"addEquals\", \"asin\", \n"
  	"\"bitAt\", \"bitCount\", \"bitwiseAnd\", \"bitwiseNot\", \"bitwiseOr\", \"bitwiseXor\", \"byteAt\", \"ceil\", \n"
  	"\"cos\", \"cosh\", \"distanceTo\", \"dotProduct\", \"duplicateIndexes\", \"isZero\", \n"
  	"\"log\", \"log10\", \"logicalOr\", \"max\", \"mean\", \"meanSquare\", \"min\", \"negate\", \"normalize\",  \n"
  	"\"product\", \"rangeFill\", \"removeEvenIndexes\", \"removeOddIndexes\", \"rootMeanSquare\", \n"
  	"\"setX\", \"setY\", \"setZ\", \"sin\", \"sinh\", \"sort\", \"sqrt\", \"square\", \"sum\", \n"
  	"\"tan\", \"tanh\", \"toBase\", \"translate\", \"x\", \"y\", \"z\", \"zero\") foreach(slotName, Sequence moveSlotToObject(slotName, Vector))\n"
  	"\n"
  	"Sequence appendProto(Vector)\n"
  	"*/\n"
  	"\n"
  	"Lobby Protos Core do(\n"
  	"	ImmutableSequence := \"\"\n"
  	"	String := ImmutableSequence\n"
  	")\n"
  	"\n"
  	"Sequence do(\n"
  	"	validEncodings := \"ascii utf8 ucs2 ucs4 number\" split\n"
  	"	validItemTypes := \"uint8 uint16 uint32 uint64 int8 int16 int32 int64 float32 float64\" split\n"
  	"	setSlot(\"..\", method(arg, self asString cloneAppendSeq(arg asString)))\n"
  	"\n"
  	"	//doc Sequence repeated(n) Returns a new sequence containing the receiver repeated n number of times.\n"
  	"	repeated := method(n,\n"
  	"		s := Sequence clone\n"
  	"		n repeat(s appendSeq(self))\n"
  	"		s\n"
  	"	)\n"
  	"\n"
  	"	//doc Sequence alignLeftInPlace(width, [padding]) Same as align left but operation is performed on the receiver.\n"
  	"	alignLeftInPlace := method(width, padding,\n"
  	"		originalSize := size\n"
  	"		if(padding isNil or padding size == 0,\n"
  	"			padding = \" \"\n"
  	"		)\n"
  	"		((width - size) / padding size) ceil repeat(appendSeq(padding))\n"
  	"		setSize(width max(originalSize))\n"
  	"	)\n"
  	"\n"
  	"	/*doc Sequence alignLeft(width, [padding]) \n"
  	"	Example:\n"
  	"	<p>\n"
  	"	<code>\n"
  	"	Io> \"abc\" alignLeft(10, \"+\")\n"
  	"	==> abc+++++++\n"
  	"	Io> \"abc\" alignLeft(10, \"-=\")\n"
  	"	==> abc-=-=-=-\n"
  	"	</code>\n"
  	"	*/\n"
  	"	\n"
  	"	alignLeft := method(width, padding, asMutable alignLeftInPlace(width, padding))\n"
  	"\n"
  	"	/*doc Sequence alignRight(width, [padding]) \n"
  	"	Example:\n"
  	"	<p>\n"
  	"	<code>\n"
  	"	Io> \"abc\" alignRight(10, \"-\")\n"
  	"	==> -------abc\n"
  	"	Io> \"abc\" alignRight(10, \"-=\")\n"
  	"	==> -=-=-=-abc\n"
  	"	</code>\n"
  	"	*/\n"
  	"	\n"
  	"	alignRight := method(width, padding,\n"
  	"		Sequence clone alignLeftInPlace(width - size, padding) appendSeq(self)\n"
  	"	)\n"
  	"\n"
  	"	/*doc Sequence alignCenter(width, [padding]) \"\"\n"
  	"	Example:\n"
  	"	<code>\n"
  	"	Io> \"abc\" alignCenter(10, \"-\")\n"
  	"	==> ---abc----\n"
  	"	Io> \"abc\" alignCenter(10, \"-=\")\n"
  	"	==> -=-abc-=-=\n"
  	"	</code>\n"
  	"	*/\n"
  	"	\n"
  	"	alignCenter := method(width, padding,\n"
  	"		alignRight(((size + width) / 2) floor, padding) alignLeftInPlace(width, padding)\n"
  	"	)\n"
  	"\n"
  	"	asSimpleString := method(\"\\\"\" .. self asString asMutable escape .. \"\\\"\")\n"
  	"\n"
  	"	/*doc Sequence splitNoEmpties(optionalArg1, optionalArg2, ...)\n"
  	"		Returns a list containing the non-empty sub-sequences of the receiver divided by the given arguments.\n"
  	"		If no arguments are given the sequence is split on white space.\n"
  	"		Examples:\n"
  	"		<code>\n"
  	"		\"a   b  c d\" splitNoEmpties => list(\"a\", \"b\", \"c\", \"d\")\n"
  	"		\"a***b**c*d\" splitNoEmpties(\"*\") => list(\"a\", \"b\", \"c\", \"d\")\n"
  	"		\"a***b||c,d\" splitNoEmpties(\"*\", \"|\", \",\") => list(\"a\", \"b\", \"c\", \"d\")\n"
  	"		</code>\n"
  	"	*/\n"
  	"\n"
  	"	/*doc Sequence split Returns a list containing the sub-sequences of the receiver divided by the given arguments.\n"
  	"		If no arguments are given the sequence is split on white space.\n"
  	"	*/\n"
  	"		\n"
  	"	splitNoEmpties := method(\n"
  	"		self performWithArgList(\"split\", call evalArgs) selectInPlace(size != 0)\n"
  	"	)\n"
  	"\n"
  	"	//doc Sequence findNthSeq(aSequence, n) Returns a number with the nth occurence of aSequence.\n"
  	"	findNthSeq := method(str, n,\n"
  	"		num := self findSeq(str)\n"
  	"		if(num isNil, return nil)\n"
  	"		if(n == 1, return num)\n"
  	"		num + self exclusiveSlice(num + 1, self size) findNthSeq(str, n - 1)\n"
  	"	)\n"
  	"\n"
  	"\n"
  	"	orderedSplit := method(\n"
  	"			separators := call evalArgs\n"
  	"			if(separators size == 0, return list(self))\n"
  	"			i := 0\n"
  	"			skipped := 0\n"
  	"			r := list\n"
  	"			separators foreach(separator,\n"
  	"				j := findSeq(separator, i) ifNil(\n"
  	"					skipped = skipped + 1\n"
  	"					continue\n"
  	"				)\n"
  	"				r append(exclusiveSlice(i, j))\n"
  	"				if(skipped > 0,\n"
  	"					skipped repeat(r append(nil))\n"
  	"					skipped = 0\n"
  	"				)\n"
  	"				i = j + separator size\n"
  	"			)\n"
  	"			if(size == 0,\n"
  	"				r append(nil)\n"
  	"			,\n"
  	"				r append(exclusiveSlice(i))\n"
  	"			)\n"
  	"			skipped repeat(r append(nil))\n"
  	"			r\n"
  	"	)\n"
  	"\n"
  	"	//doc Sequence prependSeq(object1, object2, ...) Prepends given objects asString in reverse order to the receiver.  Returns self.\")\n"
  	"	prependSeq := method(self atInsertSeq(0, call evalArgs join); self)\n"
  	"\n"
  	"	//doc Sequence itemCopy Returns a new sequence containing the items from the receiver.\n"
  	"	itemCopy := method(Sequence clone copy(self))\n"
  	"\n"
  	"	sequenceSets := Map clone do(\n"
  	"		atPut(\"lowercaseSequence\",\n"
  	"			lst := list\n"
  	"			\"abcdefghijklmnopqrstuvwxyz\" foreach(v, lst append(v))\n"
  	"			lst\n"
  	"		)\n"
  	"		atPut(\"uppercaseSequence\",\n"
  	"			lst := list\n"
  	"			at(\"lowercaseSequence\") foreach(v, lst append(v asUppercase))\n"
  	"			lst\n"
  	"		)\n"
  	"		atPut(\"digitSequence\",\n"
  	"			lst := list\n"
  	"			\"0123456789\" foreach(v, lst append(v))\n"
  	"			lst\n"
  	"		)\n"
  	"		removeSlot(\"lst\")\n"
  	"		removeSlot(\"v\")\n"
  	"	)\n"
  	"	\n"
  	"	//doc Sequence reverse Reverses the ordering of all the items of the receiver. Returns copy of receiver.\n"
  	"	reverse := method(self itemCopy reverseInPlace)\n"
  	"\n"
  	"	//doc Sequence asHex Returns a hex string for the receiving sequence, e.g., \\\"abc\\\" asHex -> \\\"616263\\\".\")\n"
  	"	asHex := method(\n"
  	"		r := Sequence clone\n"
  	"		self foreach(c, r appendSeq(c asHex))\n"
  	"		r\n"
  	"	)\n"
  	"\n"
  	"	//doc Sequence print Prints contents of a sequence.\n"
  	"	if(getSlot(\"cPrint\") == nil,\n"
  	"		cPrint := getSlot(\"print\")\n"
  	"		print := method(\n"
  	"			self asUTF8 cPrint\n"
  	"		)\n"
  	"	)\n"
  	"	\n"
  	"	asDecodedList := method(List fromEncodedList(self))\n"
  	"	\n"
  	"	//doc Sequence slice Deprecated method. Use exSlice instead.\n"
  	"	slice := method(start,\n"
  	"		deprecatedWarning(\"exSlice\")\n"
  	"		performWithArgList(\"exSlice\", call evalArgs)\n"
  	"	)\n"
  	"	\n"
  	"	//doc Sequence asJson Converts to form that could be interpreted as json if it already contains json, e.g. {\"aaa\":\"bbb\"} --> \"{\\\"aaa\\\":\\\"bbb\\\"}\"\n"
  	"	asJson := method(\n"
  	"		//TODO Return unicode string with hex replacements as per http://www.json.org/\n"
  	"		replacementMap := Map clone\\\n"
  	"			atPut(\"\\\"\", \"\\\\\\\"\")\\\n"
  	"			atPut(\"/\", \"\\\\/\")\\\n"
  	"			atPut(\"\\b\", \"\\\\b\")\\\n"
  	"			atPut(\"\\f\", \"\\\\f\")\\\n"
  	"			atPut(\"\\n\", \"\\\\n\")\\\n"
  	"			atPut(\"\\t\", \"\\\\t\")\n"
  	"			\n"
  	"		\n"
  	"		\"\\\"\" .. self asMutable replaceSeq(\"\\\\\", \"\\\\\\\\\") replaceMap(replacementMap) .. \"\\\"\"\n"
  	"	)\n"
  	"\n"
  	"	fileName := method(\n"
  	"		if(self isEmpty, return(self))\n"
  	"		lastPathComponent := self split(\"/\") last\n"
  	"		parts := lastPathComponent split(\".\") \n"
  	"		if(parts size > 1,\n"
  	"			parts removeLast\n"
  	"		)\n"
  	"		parts join(\".\")\n"
  	"	)\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "B_Sequence.io");

	s = "getSlot(\"Block\") do(\n"
  	"\n"
  	"	//doc Block asSimpleString Returns a short description of the receiver.\n"
  	"	asSimpleString := method(\n"
  	"		if(scope, \"block\", \"method\") .. \"(\" .. argumentNames append(\"...\") join(\", \") .. \")\"\n"
  	"	)\n"
  	"\n"
  	"	//doc Block asString Returns a full description of the receiver with decompiled code.\n"
  	"	asString := method(\n"
  	"		Formatter clone formatBlock(getSlot(\"self\")) buffer\n"
  	"	)\n"
  	"\n"
  	"	print := method(\n"
  	"		writeln\n"
  	"		writeln(asString)\n"
  	"	)\n"
  	"\n"
  	"  	//doc Block callWithArgList(aList) Activates the block with the given argument list.\n"
  	"	callWithArgList := method(argList,\n"
  	"		getSlot(\"self\") doMessage(argList asMessage setName(\"call\"))\n"
  	"	)\n"
  	"\n"
  	"  //doc Block println Same as <tt>print</tt>.\n"
  	"	println := getSlot(\"print\")\n"
  	"    \n"
  	"  //doc Block Formatter Helper object for the <tt>asString</tt> method.\n"
  	"	Formatter := Object clone do(\n"
  	"		newSlot(\"lineNumber\", 0)\n"
  	"		newSlot(\"isLineEmpty\", true)\n"
  	"		newSlot(\"depth\", 0)\n"
  	"		newSlot(\"buffer\")\n"
  	"\n"
  	"		newSlot(\"operators\")\n"
  	"		newSlot(\"reverseAssignOperators\")\n"
  	"\n"
  	"		init := method(\n"
  	"			buffer = Sequence clone\n"
  	"			operators = OperatorTable operators\n"
  	"			reverseAssignOperators = OperatorTable reverseAssignOperators\n"
  	"			reverseAssignOperators atPut(\"setSlotWithType\", \":=\")\n"
  	"		)\n"
  	"\n"
  	"		appendSeq := method(\n"
  	"			call delegateTo(buffer)\n"
  	"			isLineEmpty = false\n"
  	"		)\n"
  	"\n"
  	"		newLine := method(\n"
  	"			buffer appendSeq(\"\\n\")\n"
  	"			lineNumber = lineNumber + 1\n"
  	"			isLineEmpty = true\n"
  	"		)\n"
  	"\n"
  	"		newLinesTo := method(msg,\n"
  	"			(msg lineNumber - lineNumber) minMax(0, 2) repeat(newLine)\n"
  	"			lineNumber = msg lineNumber\n"
  	"		)\n"
  	"\n"
  	"		indent := method(\n"
  	"			depth repeat(appendSeq(\"    \"))\n"
  	"		)\n"
  	"\n"
  	"		formatBlock := method(theBlock,\n"
  	"			msg := getSlot(\"theBlock\") message\n"
  	"\n"
  	"			if(msg label != CLI commandLineLabel,\n"
  	"				appendSeq(\"# \" .. msg label .. \":\" .. msg lineNumber, \"\\n\")\n"
  	"			)\n"
  	"			appendSeq(\"method(\")\n"
  	"			if(getSlot(\"theBlock\") argumentNames size > 0,\n"
  	"				getSlot(\"theBlock\") argumentNames foreach(i, name,\n"
  	"					if(i > 0,\n"
  	"						appendSeq(\", \")\n"
  	"					)\n"
  	"\n"
  	"					appendSeq(name)\n"
  	"				)\n"
  	"\n"
  	"				appendSeq(\", \")\n"
  	"			)\n"
  	"\n"
  	"			newLine\n"
  	"			lineNumber = msg lineNumber\n"
  	"			formatIndentedMessage(msg)\n"
  	"			newLine\n"
  	"			appendSeq(\")\")\n"
  	"			self\n"
  	"		)\n"
  	"\n"
  	"		formatIndentedMessage := method(msg,\n"
  	"			depth = depth + 1\n"
  	"			formatMessage(msg)\n"
  	"			depth = depth - 1\n"
  	"		)\n"
  	"\n"
  	"		formatMessage := method(msg,\n"
  	"			m := msg\n"
  	"			while(m,\n"
  	"				if(m isEndOfLine,\n"
  	"					if(lineNumber == m next ?lineNumber,\n"
  	"						appendSeq(m name)\n"
  	"					)\n"
  	"					m = m next\n"
  	"					continue\n"
  	"				)\n"
  	"\n"
  	"				newLinesTo(m)\n"
  	"\n"
  	"				if(isLineEmpty,\n"
  	"					indent\n"
  	"				,\n"
  	"					if(m != msg,\n"
  	"						appendSeq(\" \")\n"
  	"					)\n"
  	"				)\n"
  	"\n"
  	"				if(reverseAssignOperators hasKey(m name)) then(\n"
  	"					args := m arguments\n"
  	"\n"
  	"					if(args first cachedResult,\n"
  	"						appendSeq(args first cachedResult, \" \")\n"
  	"\n"
  	"						appendSeq(reverseAssignOperators at(m name))\n"
  	"\n"
  	"						appendSeq(\" \")\n"
  	"						if(args at(1),\n"
  	"							formatMessage(args at(1))\n"
  	"						)\n"
  	"					,\n"
  	"						appendSeq(m name)\n"
  	"						if(m argCount > 0,\n"
  	"							formatArguments(m)\n"
  	"						)\n"
  	"					)\n"
  	"				) elseif(operators hasKey(m name)) then(\n"
  	"					appendSeq(m name)\n"
  	"\n"
  	"					appendSeq(\" \")\n"
  	"					if(m arguments first,\n"
  	"						formatMessage(m arguments first)\n"
  	"					)\n"
  	"				) else(\n"
  	"					appendSeq(m name)\n"
  	"					if(m argCount > 0,\n"
  	"						formatArguments(m)\n"
  	"					)\n"
  	"				)\n"
  	"\n"
  	"				m = m next\n"
  	"			)\n"
  	"		)\n"
  	"\n"
  	"		formatArguments := method(msg,\n"
  	"			appendSeq(\"(\")\n"
  	"\n"
  	"			startingLineNumber := lineNumber\n"
  	"			msg arguments foreach(i, arg,\n"
  	"				# Insert separator between arguments\n"
  	"				if(i > 0,\n"
  	"					# Still on the same line as the \"(\"\n"
  	"					if(startingLineNumber == lineNumber,\n"
  	"						appendSeq(\", \")\n"
  	"					,\n"
  	"						newLine; indent; appendSeq(\",\"); newLine\n"
  	"					)\n"
  	"				)\n"
  	"\n"
  	"				# Format the argument\n"
  	"				formatIndentedMessage(arg)\n"
  	"			)\n"
  	"\n"
  	"			if(startingLineNumber != lineNumber,\n"
  	"				newLine\n"
  	"				indent\n"
  	"			)\n"
  	"			appendSeq(\")\")\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "Block.io");

	s = "getSlot(\"CFunction\") do(\n"
  	"\n"
  	"	//doc CFunction name Returns the CFunction name in the form CFunction_Pointer.\")\n"
  	"	name := method(typeName ifNilEval(\"Object\") .. \"_\" .. uniqueName ifNilEval(\"<unnamed>\") .. \"()\")\n"
  	"\n"
  	"	//doc CFunction asSimpleString Returns the CFunction name.\n"
  	"	asSimpleString := method(name)\n"
  	"\n"
  	"	//doc CFunction asString Same as asSimpleString.\n"
  	"	asString := getSlot(\"asSimpleString\")\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "CFunction.io");

	s = "Date do(\n"
  	"	/*doc Date today \n"
  	"	Set the receiver to the current date, no time information\n"
  	"	is included. See `now' for the current date and time.\n"
  	"	*/\n"
  	"	\n"
  	"	today := method(Date now setHour(0) setMinute(0) setSecond(0))\n"
  	"\n"
  	"	//doc Date isToday Returns true if the receiver's date is today's date.\n"
  	"	isToday := method(\n"
  	"		now := Date clone now\n"
  	"		now year == year and now month == month and now day == day\n"
  	"	)\n"
  	"\n"
  	"	//doc Date secondsToRun(expression) Evaluates message and returns a Number whose value is the number of seconds taken to do the evaluation\n"
  	"	secondsToRun := method(\n"
  	"		t1 := Date clone now\n"
  	"		call relayStopStatus(call evalArgAt(0))\n"
  	"		dt := Date clone now secondsSince(t1)\n"
  	"	)\n"
  	"\n"
  	"	//doc Date asAtomDate Returns the date formatted as a valid atom date (rfc4287) in the system's timezone.\n"
  	"	Date asAtomDate := method(\n"
  	"		asString(\"%Y-%m-%dT%H:%M:%S\") .. gmtOffset asMutable atInsertSeq(3, \":\")\n"
  	"	)\n"
  	"	\n"
  	"	asJson := method(asString asJson)\n"
  	"			\n"
  	"	justSerialized := method(stream,\n"
  	"		stream write(\"Date clone do(\",\n"
  	"			\"setYear(\", self year, \") \",\n"
  	"			\"setMonth(\", self month, \") \",\n"
  	"			\"setDay(\", self day, \") \",\n"
  	"			\"setHour(\", self hour, \") \",\n"
  	"			\"setMinute(\", self minute, \") \",\n"
  	"			\"setSecond(\", self second, \")\",\n"
  	"			\");\")\n"
  	"	)\n"
  	"	\n"
  	"	asNumberString := method(\n"
  	"		self asNumber asString alignLeft(27, \"0\")\n"
  	"	)\n"
  	"	\n"
  	"	timeStampString := method(\n"
  	"		Date clone now asNumber asString alignLeft(27, \"0\")\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Duration do(\n"
  	"	//doc Duration + Returns a new Duration of the two added.\n"
  	"	setSlot(\"+\", method(d, self clone += d))\n"
  	"\n"
  	"	//doc Duration - Returns a new Duration of the two subtracted.\n"
  	"	setSlot(\"-\", method(d, self clone -= d))\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "Date.io");

	s = "Debugger do(\n"
  	"	/*doc Debugger description\n"
  	"	To start debugging a coroutine, call\n"
  	"	<code>\n"
  	"	Coroutine currentCoroutine setMessageDebugging(true)\n"
  	"	</code>\n"
  	"	Then each message sent within that coroutine will cause the Debugger \n"
  	"	vmWillSendMessage slot to be activated and the Debugger slots: \n"
  	"	messageCoroutine, messageSelf, messageLocals, and message will be set with the \n"
  	"	values related to the current message send. You can override vmWillSendMessage to \n"
  	"	implement your own debugging mechanisms.\n"
  	"	*/\n"
  	"\n"
  	"	//doc Debugger start Starts the debugger.\n"
  	"	start := method(\n"
  	"		loop(\n"
  	"			self vmWillSendMessage(self message name)\n"
  	"			messageCoroutine resume\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	//doc Debugger vmWillSendMessage Override this method to implement your own debugging mechanisms. Default behavior is to print every message sent.\n"
  	"	vmWillSendMessage := method(\n"
  	"		writeln(\"Debugger vmWillSendMessage(\", self message name, \")\")\n"
  	"	)\n"
  	"\n"
  	"	//doc Debugger debuggerCoroutine Returns the coroutine used for the debugger.\n"
  	"	debuggerCoroutine := coroFor(start)\n"
  	"	yield\n"
  	")\n"
  	"\n"
  	"\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "Debugger.io");

	s = "Directory do(\n"
  	"	//doc Directory with(aPath) Returns a new instance with the provided path.\n"
  	"	with := method(path, self clone setPath(path))\n"
  	"\n"
  	"    /*doc Directory walk\n"
  	"    Recursively walks the current directory, and executes a given callback on\n"
  	"    each item (either File or Directory) found, excluding \".\" and \"..\".\n"
  	"<pre>\n"
  	"Io> Directory walk(println)\n"
  	"A0_List.io\n"
  	"A1_OperatorTable.io\n"
  	"...\n"
  	"Io> Directory walk(f, if(f name startsWithSeq(\"Directory\"), f println))\n"
  	"Directory.io\n"
  	"</pre>\n"
  	"    */\n"
  	"    walk := method(\n"
  	"        # We call a given message on each file in the directory, being walked...\n"
  	"        call delegateToMethod(\n"
  	"            items select(item, item name != \".\" and item name !=\"..\"), \"map\"\n"
  	"        )\n"
  	"        # .. and then recursively walk all subdirectories, if there is any.\n"
  	"        if(directories size > 0,\n"
  	"            directories map(dir, call delegateTo(dir))\n"
  	"        )\n"
  	"        nil\n"
  	"    )\n"
  	"\n"
  	"	//doc Directory createIfAbsent Creates the directory (and any missing ancestor directories) if they don't exist. Returns self.\n"
  	"	createIfAbsent := method(\n"
  	"		if(self exists not,\n"
  	"			if(parentDirectory and parentDirectory exists not, parentDirectory createIfAbsent)\n"
  	"			self create\n"
  	"		)\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory parentDirectory Returns the parent directory object or nil if there is no parent directory.\n"
  	"	parentDirectory := method(\n"
  	"		if(path == \".\", return nil)\n"
  	"		p := self path pathComponent\n"
  	"		if(p == \"\", p = \".\")\n"
  	"		Directory clone setPath(p)\n"
  	"	)\n"
  	"\n"
  	"    //doc Directory directories Returns a list of subdirectories in the receiver.\n"
  	"    directories := method(\n"
  	"        items select(item,\n"
  	"            item isKindOf(Directory) and item name != \".\" and item name != \"..\"\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"	//doc Directory folders Deprecated. Replaced by directories().\n"
  	"	folders := method(\n"
  	"		deprecatedWarning(\"directories()\")\n"
  	"		directories\n"
  	"	)\n"
  	"\n"
  	"    //doc Directory isAccessible Returns true if the directory can be accessed, false otherwise.\n"
  	"    isAccessible := method(\n"
  	"        # Why catch Exception here? can any other errors occur?\n"
  	"        r := true\n"
  	"        try(items) catch(Exception, r = false)\n"
  	"        r\n"
  	"    )\n"
  	"\n"
  	"	//doc Directory ancestorDirectories Returns a list of ancestor directories.\n"
  	"	ancestorDirectories := method(\n"
  	"		list := List clone\n"
  	"		d := self\n"
  	"		while(d = d parentDirectory, list append(d))\n"
  	"		list reverseInPlace\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory accessibleAncestors Returns a list of accessible ancestor directories.\n"
  	"	accessibleAncestors := method(ancestorDirectories select(isAccessible))\n"
  	"\n"
  	"	//doc Directory parents Deprecated. Replaced by ancestorDirectories.\n"
  	"	parents := method(\n"
  	"		deprecatedWarning(\"ancestorDirectories\")\n"
  	"		ancestorDirectories\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory accessibleParents Deprecated. Replaced by accessibleAncestors.\n"
  	"	accessibleParents := method(\n"
  	"		deprecatedWarning(\"accessibleAncestors\")\n"
  	"		accessibleAncestors\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory files Returns a list of File objects for the files in the Directory (no directories).\n"
  	"	files := method(items select(type == \"File\"))\n"
  	"\n"
  	"	//doc Directory fileNames Returns a list of strings for the names of the files (no subdirectories) in the directory.\n"
  	"	fileNames := method(files mapInPlace(name))\n"
  	"\n"
  	"	//doc Directory fileNamed(aName) Returns a File object for the specified file name whether it exists or not.\n"
  	"	fileNamed := method(name,\n"
  	"		//files detect(i, v, v name == name)\n"
  	"		File clone setPath(Path with(path, name))\n"
  	"	)\n"
  	"\n"
  	"    /*doc Directory recursiveFilesOfTypes(suffixes)\n"
  	"    Returns a list containing all files in the directory or any subdirectory that\n"
  	"    has any of the specified suffixes.\n"
  	"    */\n"
  	"     recursiveFilesOfTypes := method(suffixes,\n"
  	"        # ^\n"
  	"        # |\n"
  	"        # horrible name, really\n"
  	"        found := list()\n"
  	"        walk(item,\n"
  	"            if(item isKindOf(File) and \\\n"
  	"               suffixes detect(suffix, item name endsWithSeq(suffix)),\n"
  	"                found append(item)\n"
  	"            )\n"
  	"        )\n"
  	"        found\n"
  	"    )\n"
  	"\n"
  	"    /*doc Directory filesWithExtension(aString)\n"
  	"    Returns a list of File objects for the files in the Directory (no directories)\n"
  	"    with the specified file extension.\n"
  	"    */\n"
  	"    filesWithExtension := method(ext,\n"
  	"        if(ext containsSeq(\".\") not, ext = \".\" .. ext)\n"
  	"        files select(name endsWithSeq(ext))\n"
  	"    )\n"
  	"\n"
  	"	//doc Directory directoryNamed(aName) Returns a Directory object for the specified file name whether or not it exists.\n"
  	"	directoryNamed := method(name,\n"
  	"		Directory with(Path with(path, name))\n"
  	"		//directories detect(i, v, v name == name)\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory folderNamed(aName) Deprecated. Replaced by directoryNamed().\n"
  	"	folderNamed := method(name,\n"
  	"		deprecatedWarning(\"directoryNamed(name)\")\n"
  	"		directoryNamed(name)\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory localItems All subitems excluding '.' and '..'.\n"
  	"	Directory localItems := method( \n"
  	"		items select(item, if(item name != \".\" and item name != \"..\"))\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory remove Removes the directory.\n"
  	"	remove := method(\n"
  	"		localItems foreach(remove)\n"
  	"		File clone setPath(self path) remove\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory folderNamedCreateIfAbsent(name) Deprecated. Returns a new Directory object in the directory with the specified name.\n"
  	"	folderNamedCreateIfAbsent := method(name,\n"
  	"		deprecatedWarning(\"directoryNamed(name) create\")\n"
  	"		f := folderNamed(name)\n"
  	"		if(f, return f)\n"
  	"		createSubdirectory(name)\n"
  	"		folderNamed(name)\n"
  	"	)\n"
  	"\n"
  	"	//doc Directory createFileNamed(name) Deprecated. Returns a new file object in the directory with the specified name.\n"
  	"	createFileNamed := method(name,\n"
  	"		deprecatedWarning(\"fileNamed(name) create\")\n"
  	"		f := fileNamed(name)\n"
  	"		if(f, return f)\n"
  	"		return File clone setPath(Path with(path, name))\n"
  	"	)\n"
  	"\n"
  	"    //doc Directory moveTo(aPath) Moves the directory to the specified path.\n"
  	"    moveTo := method(path,\n"
  	"        File with(self path) moveTo(path)\n"
  	"        # Setting path slot to the new location, if everything went okay.\n"
  	"        self setPath(path)\n"
  	"    )\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "Directory.io");

	s = "DynLib do(\n"
  	"	init := method(\n"
  	"		self forward := method(\n"
  	"			self performWithArgList(\"call\", list(call message name, call message arguments map(x, self doMessage(x))) flatten)\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "DynLib.io");

	s = "Object do(\n"
  	"  //doc Object ifError Does nothing, returns self.\n"
  	"	ifError := method(self)\n"
  	"	//doc Object returnIfError Does nothing, returns self.\n"
  	"	returnIfError := getSlot(\"ifError\")\n"
  	"	//doc Object raiseIfError Does nothing, returns self.\n"
  	"	raiseIfError  := getSlot(\"ifError\")\n"
  	"	//doc Object isError Returns false if not an error.\n"
  	"	isError := false\n"
  	")\n"
  	"\n"
  	"Error do(\n"
  	"  /*doc Error ifError(code) \n"
  	"  Evaluates code in the context of sender. Returns self.\n"
  	"  <br/>\n"
  	"  Another form is <tt>Error ifError(error, code)</tt>. \n"
  	"  Note: <tt>error</tt> slot is set in the context of sender, Locals object is not created!\n"
  	"  */\n"
  	"	ifError := method(\n"
  	"		if(call message arguments size == 1) then(\n"
  	"			call evalArgAt(0)\n"
  	"		) elseif(call message arguments size > 1) then(\n"
  	"			call sender setSlot(call message argAt(0) name, self)\n"
  	"			call evalArgAt(1)\n"
  	"		) else(\n"
  	"			Exception raise(\"ifError requires at least 1 argument\")\n"
  	"		)\n"
  	"		self\n"
  	"	) setPassStops(true)\n"
  	"	\n"
  	"	//doc Error returnIfError Returns self from the context of sender.\n"
  	"	returnIfError := method(\n"
  	"		call sender return(self)\n"
  	"	) setPassStops(true)\n"
  	"	\n"
  	"	//doc Error raiseIfError Raises exception.\n"
  	"	raiseIfError := method( //message,\n"
  	"		Exception raise(message)\n"
  	"	)\n"
  	"	\n"
  	"	//doc Error with(message) Returns new error with message slot set.\n"
  	"	with := method(message,\n"
  	"		error := self clone\n"
  	"		error message := message\n"
  	"		error location := call message label .. \":\" .. call message lineNumber\n"
  	"		error\n"
  	"	)\n"
  	"\n"
  	"	withShow := method(s,\n"
  	"		writeln(\"ERROR: \", s)\n"
  	"		error := self clone\n"
  	"		error message := message\n"
  	"		error location := call message label .. \":\" .. call message lineNumber\n"
  	"		error\n"
  	"	)\n"
  	"		\n"
  	"	//doc Error isError Returns true.\n"
  	"	isError := true\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "Error.io");

	s = "File do(\n"
  	"	//doc File with(aPath) Returns a new instance with the provided path.\n"
  	"	with := method(path, self clone setPath(path))\n"
  	"\n"
  	"	//doc File streamDestination The buffer object to be used for future stream operations. \n"
  	"	//doc File setStreamDestination(aBuffer) Set the buffer to be used for future stream operations. \n"
  	"	streamDestination ::= nil\n"
  	"	\n"
  	"	//doc File streamReadSize Size of stream buffer used for streaming operations\n"
  	"	streamReadSize := 65536\n"
  	"	\n"
  	"	//doc File startStreaming Begin streamed read to stream destination set by setStreamDestination(aBuffer).\n"
  	"	startStreaming := method(streamTo(streamDestination))\n"
  	"\n"
  	"	//doc File exitStatus System's close status (after file close).\n"
  	"  	exitStatus := nil\n"
  	"\n"
  	"	//doc File termSignal Pipe's terminating signal (after file close opened via popen).\n"
  	"  	termSignal := nil\n"
  	"\n"
  	"	//doc File streamTo(aBuffer) Perform streamed reading to given buffer. The buffer will be appended with chunks of size streamReadSize until EOF. The final chunk may be less than streamReadSize.\n"
  	"	streamTo := method(streamDestination,\n"
  	"		b := Sequence clone\n"
  	"		self open\n"
  	"		while(isAtEnd not,\n"
  	"			b empty\n"
  	"			readToBufferLength(b, streamReadSize)\n"
  	"			streamDestination write(b)\n"
  	"			yield\n"
  	"		)\n"
  	"	)\n"
  	"	\n"
  	"	//doc File streamToWithoutYielding(aBuffer) Perform streamed reading to given buffer without yielding between reads.\n"
  	"	streamToWithoutYielding := method(streamDestination,\n"
  	"		b := Sequence clone\n"
  	"		self open\n"
  	"		while(isAtEnd not,\n"
  	"			b empty\n"
  	"			readToBufferLength(b, streamReadSize)\n"
  	"			streamDestination write(b)\n"
  	"		)\n"
  	"	)\n"
  	"	\n"
  	"	//doc File copyToPathWithoutYielding(destinationPath) Copies the file to the specified path without yielding.\n"
  	"	copyToPathWithoutYielding := method(dstPath,\n"
  	"		dst := File with(dstPath) open\n"
  	"		self open streamToWithoutYielding(dst)\n"
  	"		dst close\n"
  	"		self close\n"
  	"		self\n"
  	"	)\n"
  	"	\n"
  	"	//doc File copyToPath(destinationPath) Copies the file to the specified path.\n"
  	"	copyToPath := method(dstPath,\n"
  	"		dst := File with(dstPath) open\n"
  	"		self open streamTo(dst)\n"
  	"		dst close\n"
  	"		self close\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	/*\n"
  	"	// doc File lockFile Deprecated. The .lock file used for File locking.\n"
  	"	lockFile := method(File clone setPath(path .. \".lock\"))\n"
  	"\n"
  	"	// doc File lock Creates a path.lock file if it does not exist. If it does exist, it waits for it be removed by the process that created it first. Returns self.\n"
  	"	lock := method(timeout,\n"
  	"		if(timeout == nil, timeout = 10)\n"
  	"		lockFile := lockFile\n"
  	"		waitTime := .1\n"
  	"		waited := 0\n"
  	"		// a bit of a hack - this isn't atomic\n"
  	"		while(lockFile exists,\n"
  	"			wait(waitTime)\n"
  	"			waited = waited + waitTime\n"
  	"			if(waited > timeout, Exception raise(\"unable to acquire lock on \" .. path))\n"
  	"		)\n"
  	"		lockFile open close\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	unlock := method(lockFile remove)\n"
  	"	*/\n"
  	"	\n"
  	"	//doc File setContents(aSeq) Replaces the contents for the file with aSeq. Returns self.\n"
  	"	setContents := method(d, self truncateToSize(0) open write(d) close; self)\n"
  	"	\n"
  	"	//doc File appendToContents(aSeq) Appends to the contents of the file with aSeq. Returns self.\n"
  	"	appendToContents := method(\n"
  	"		openForAppending\n"
  	"		call evalArgs foreach(seq,\n"
  	"			self write(seq) \n"
  	"		)\n"
  	"		close\n"
  	"		self\n"
  	"	)\n"
  	"	\n"
  	"	//doc File readToEnd(chunkSize) Reads chunkSize bytes (4096 by default) at a time until end of file is reached.  Returns a sequence containing the bytes read from the file.\n"
  	"	readToEnd := method(chunkSize,\n"
  	"		if(chunkSize not, chunkSize = 4096)\n"
  	"		buffer := Sequence clone\n"
  	"		while(readToBufferLength(buffer, chunkSize) == chunkSize, nil)\n"
  	"		buffer\n"
  	"	)\n"
  	"	\n"
  	"	//doc File create Creates an empty file at the file's path. Returns self on success, nil on failure.\n"
  	"	create := method(\n"
  	"		if(open, close; self, nil)\n"
  	"	)\n"
  	"	\n"
  	"	//doc File baseName Returns File's name without an extension (returned Sequence consists of all characters up to final period [\".\"] character).\n"
  	"	baseName := method(\n"
  	"		name split(\".\") slice(0, -1) join(\".\")\n"
  	"	)\n"
  	"	\n"
  	"	//doc File thisSourceFile Returns a File representing the system file in which this Io code exists.\n"
  	"	thisSourceFile := method(\n"
  	"		File with(Path with(call message label))\n"
  	"	)\n"
  	"	\n"
  	"	//doc File containingDirectory Deprecated. See parentDirectory.\n"
  	"	containingDirectory := method(\n"
  	"		deprecatedWarning(\"parentDirectory\")\n"
  	"		parentDirectory\n"
  	"	)\n"
  	"	\n"
  	"	//doc File parentDirectory Returns a File for the directory that is the parent directory of this object's path. \n"
  	"	parentDirectory := method(\n"
  	"		Directory with(path pathComponent)\n"
  	"	)\n"
  	"	\n"
  	"	standardOutput := File standardOutput\n"
  	"	standardInput  := File standardInput\n"
  	")\n"
  	"\n"
  	"Sequence do(\n"
  	"	//doc Sequence asFile Returns a new File object with the receiver as its path.\n"
  	"	asFile := method(\n"
  	"		File with(self)\n"
  	"	)\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "File.io");

	s = "/*\n"
  	"http://www.quag.geek.nz/io/schwartzian/\n"
  	"\n"
  	"A decorate-sort-undecorate operation for Io\n"
  	"\n"
  	"Specify a key for each item, and control how the keys are compared.\n"
  	"\n"
  	"Io> Range\n"
  	"Io> 0 to(10) asList sortByKey(x, (-1)**x * x)\n"
  	"==> list(9, 7, 5, 3, 1, 0, 2, 4, 6, 8, 10)\n"
  	"\n"
  	"Io> Directory with(\".\") files sortKey(lastInfoChangeDate) sort map(name)\n"
  	"==> ... listing of directory sorted by date\n"
  	"\n"
  	"Two forms of sortKey are supported:\n"
  	"\n"
  	"	* files sortKey(lastInfoChangeDate)\n"
  	"	* files sortKey(file, file lastInfoChangeDate)\n"
  	"\n"
  	"Three forms of sort are supported:\n"
  	"\n"
  	"	* files sortKey(...) sort\n"
  	"	* files sortKey(...) sort(<)\n"
  	"	* files sortKey(...) sort(x, y, x < y)\n"
  	"*/\n"
  	"\n"
  	"List sortByKey := method(\n"
  	"	call delegateToMethod(self, \"sortKey\") sort\n"
  	")\n"
  	"\n"
  	"List sortKey := method(\n"
  	"	schwart := call activated SchwartzianList clone\n"
  	"	if(call argCount == 1,\n"
  	"		body := call argAt(0)\n"
  	"		foreach(value,\n"
  	"			ss := stopStatus(k := value doMessage(body, call sender))\n"
  	"			if(ss isReturn, ss return(k))\n"
  	"			if(ss isBreak, break)\n"
  	"			if(ss isContinue, continue)\n"
  	"			schwart addPair(k, value)\n"
  	"		)\n"
  	"	,\n"
  	"		valueName := call argAt(0) name\n"
  	"		foreach(value,\n"
  	"			call sender setSlot(valueName, value)\n"
  	"			ss := stopStatus(k := call evalArgAt(1))\n"
  	"			if(ss isReturn, ss return(k))\n"
  	"			if(ss isBreak, break)\n"
  	"			if(ss isContinue, continue)\n"
  	"			schwart addPair(k, value)\n"
  	"		)\n"
  	"	)\n"
  	"	schwart\n"
  	") do(\n"
  	"	SchwartzianList := Object clone do(\n"
  	"		newSlot(\"pairs\")\n"
  	"\n"
  	"		init := method(\n"
  	"			pairs = list\n"
  	"		)\n"
  	"\n"
  	"		SchwartzianPair := Object clone do(\n"
  	"			newSlot(\"key\")\n"
  	"			newSlot(\"value\")\n"
  	"\n"
  	"			asSimpleString := method(\n"
  	"				\"(\" .. key asSimpleString .. \": \" .. value asSimpleString .. \")\"\n"
  	"			)\n"
  	"		)\n"
  	"\n"
  	"		addPair := method(key, value,\n"
  	"			pairs append(SchwartzianPair clone setKey(key) setValue(value))\n"
  	"		)\n"
  	"\n"
  	"		sort := method(\n"
  	"			if(call argCount == 0,\n"
  	"				pairs sortBy(block(x, y, x key < y key))\n"
  	"			,\n"
  	"				if(call argCount == 1,\n"
  	"					opName := call argAt(0) name\n"
  	"					args := list(nil)\n"
  	"					pairs sortBy(\n"
  	"						block(x, y,\n"
  	"							x key performWithArgList(opName, args atPut(0, y key))\n"
  	"						)\n"
  	"					)\n"
  	"				,\n"
  	"					sortCall := call\n"
  	"					xName := sortCall argAt(0) name\n"
  	"					yName := sortCall argAt(1) name\n"
  	"					pairs sortBy(\n"
  	"						block(x, y,\n"
  	"							sortCall sender setSlot(xName, x key)\n"
  	"							sortCall sender setSlot(yName, y key)\n"
  	"							sortCall evalArgAt(2)\n"
  	"						)\n"
  	"					)\n"
  	"				)\n"
  	"			) mapInPlace(p, p value)\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "List_schwartzian.io");

	s = "Map do(\n"
  	"	//doc Map with(key1, value1, key2, value2, ...) Returns a new map containing the given keys and values\n"
  	"	with := method(\n"
  	"		m := Map clone\n"
  	"		args := call message arguments\n"
  	"		for(i, 0, args size - 1, 2,\n"
  	"			m atPut(call evalArgAt(i), call evalArgAt(i+1))\n"
  	"		)\n"
  	"		m\n"
  	"	)\n"
  	"\n"
  	"	//doc Map asJson Converts a Map to a string that represents contents in JSON-compilant form\n"
  	"	asJson := method(\n"
  	"		\"{\" .. self keys map(k, k asJson .. \":\" .. self at(k) asJson) join(\",\") .. \"}\"\n"
  	"	)\n"
  	"\n"
  	"	//doc Map asList Converts a Map to a list of lists. Each element in the returned list will be a list of two elements: the key, and the value.\n"
  	"	asList := method(\n"
  	"		self keys map(k, list(k, self at(k)))\n"
  	"	)\n"
  	"\n"
  	"	/*doc Map map(key, value, message)\n"
  	"		Create a List of results of message applied to self's items in a random\n"
  	"		order.\n"
  	"	*/\n"
  	"	map := method(\n"
  	"		result := List clone\n"
  	"		key := call argAt(0)\n"
  	"		value := call argAt(1)\n"
  	"		body := call argAt(2)\n"
  	"		self foreach(k, v,\n"
  	"			call sender setSlot(key name, k)\n"
  	"			call sender setSlot(value name, v)\n"
  	"			ss := stopStatus(r := call sender doMessage(body))\n"
  	"			if(ss isReturn, call setStopStatus(ss); return getSlot(\"v\"))\n"
  	"			if(ss isBreak, break)\n"
  	"			if(ss isContinue, continue)\n"
  	"			result append(getSlot(\"r\"))\n"
  	"		)\n"
  	"		result\n"
  	"	)\n"
  	"\n"
  	"	/*doc Map select(optionalIndex, optionalValue, message)\n"
  	"		Create a new Map with keys,values of self for which message evaluated\n"
  	"		to non-nil.\n"
  	"	*/\n"
  	"	select := method(\n"
  	"		result := Map clone\n"
  	"		self keys foreach(key,\n"
  	"			if(call argCount > 1,\n"
  	"				call sender setSlot(call argAt(0) name, key)\n"
  	"				if(call argCount == 3,\n"
  	"					call sender setSlot(call argAt(1) name, self at(key))\n"
  	"				)\n"
  	"			)\n"
  	"			ss := stopStatus(v := call evalArgAt(call argCount - 1))\n"
  	"			if(ss isReturn, call setStopStatus(ss); return getSlot(\"v\"))\n"
  	"			if(ss isBreak, break)\n"
  	"			if(ss isContinue, continue)\n"
  	"			if(getSlot(\"v\"),\n"
  	"				result atPut(key, self at(key))\n"
  	"			)\n"
  	"		)\n"
  	"		result\n"
  	"	)\n"
  	"\n"
  	"	/*doc Map detect(optionalIndex, optionalValue, message)\n"
  	"		Returns a random value for which message evals to non-nil.\n"
  	"	*/\n"
  	"	detect := method(\n"
  	"		self keys foreach(key,\n"
  	"			if(call argCount > 1,\n"
  	"				call sender setSlot(call argAt(0) name, key)\n"
  	"				if(call argCount == 3,\n"
  	"					call sender setSlot(call argAt(1) name, self at(key))\n"
  	"				)\n"
  	"			)\n"
  	"			ss := stopStatus(v := call evalArgAt(call argCount - 1))\n"
  	"			if(ss isReturn, call setStopStatus(ss); return getSlot(\"v\"))\n"
  	"			if(ss isBreak, break)\n"
  	"			if(ss isContinue, continue)\n"
  	"			if(getSlot(\"v\"),\n"
  	"				return list(key, self at(key))\n"
  	"			)\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	/*doc Map merge(anotherMap)\n"
  	"		Returns a new map created by merging the pairs from anotherMap into this map\n"
  	"	*/\n"
  	"	merge := method(anotherMap,\n"
  	"		self clone mergeInPlace(anotherMap)\n"
  	"	)\n"
  	"\n"
  	"	/*doc Map mergeInPlace(anotherMap)\n"
  	"		Merges the pairs from anotherMap into this map\n"
  	"	*/\n"
  	"	mergeInPlace := method(anotherMap,\n"
  	"		addKeysAndValues(anotherMap keys, anotherMap values)\n"
  	"	)\n"
  	"\n"
  	"	//doc Map reverseMap Create a new Map using values as keys and keys as values\n"
  	"	reverseMap := method(\n"
  	"		Map clone addKeysAndValues(values, keys)\n"
  	"	)\n"
  	"\n"
  	"	//doc Map asObject Create a new Object whose slotDescriptionMap will be equal to self\n"
  	"	asObject := method(\n"
  	"		o := Object clone\n"
  	"		self foreach(k, v, o setSlot(k, getSlot(\"v\")))\n"
  	"		o\n"
  	"	)\n"
  	"\n"
  	"	//doc Map isEmpty returns true if this map doesn't contain any pairs.\n"
  	"	isEmpty := method(\n"
  	"		keys isEmpty\n"
  	"	)\n"
  	"\n"
  	"    //doc Map isNotEmpty returns true if this map contains at least one pair.\n"
  	"    isNotEmpty := method(\n"
  	"        keys isNotEmpty\n"
  	"    )\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "Map.io");

	s = "Message do(\n"
  	"	/*doc Message union(other) Creates a union of the receiver and the other parameter. \n"
  	"	Returns a new message object with the receivers message as the first argument of the returned message, \n"
  	"	and the other parameter's arguments as each successive argument to the new message.\n"
  	"	<br/>\n"
  	"	<pre>\n"
  	"  Io> message(a) union(message(b))\n"
  	"  ==> [unnamed](a, b)\n"
  	"  </pre>\n"
  	"	*/\n"
  	"	union := method(\n"
  	"		r := Message clone\n"
  	"		l := list(self)\n"
  	"		call message argAt(0) arguments foreach(arg, l append(arg))\n"
  	"		r setArguments(l)\n"
  	"	)\n"
  	"	\n"
  	"  //doc Message asSimpleString Returns one-line string representation up to 40 characters long.\n"
  	"	asSimpleString := method(\n"
  	"		s := self asString asMutable replaceSeq(\" ;\\n\", \"; \")\n"
  	"		if(s size > 40,\n"
  	"			s exclusiveSlice(0, 37) .. \"...\"\n"
  	"		,\n"
  	"			s\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "Message.io");

	s = "Number do(\n"
  	"	//doc Number isInASequenceSet Return true if receiver is in one of the Sequence sequenceSets, otherwise false.\n"
  	"	isInASequenceSet := method(\n"
  	"		Sequence sequenceSets foreach(set,\n"
  	"			if(in(set), return true)\n"
  	"		)\n"
  	"		false\n"
  	"	)\n"
  	"\n"
  	"	//doc Number constants Object containing number constants e, inf, nan and pi.\n"
  	"\n"
  	"	constants := Object clone do(\n"
  	"		//doc Number nan Returns a infinity constant.\n"
  	"		nan := 0/0\n"
  	"\n"
  	"		//doc Number inf Returns a not-a-number constant.\n"
  	"		inf := 1/0\n"
  	"\n"
  	"		//doc Number e Returns the constant e.\n"
  	"		e  := 2.71828182845904523536028747135266249\n"
  	"\n"
  	"		//doc Number pi Returns the constant pi.\n"
  	"		pi := 3.14159265358979323846264338327950288\n"
  	"	)\n"
  	"\n"
  	"	asSimpleString := method(self asString)\n"
  	"\n"
  	"	//doc Number toBase(base) Returns the number in another base. 42 toBase(2) -> \"101010\"\n"
  	"	toBase := method(base, self asString toBase(base))\n"
  	"\n"
  	"        //doc Number toBaseWholeBytes(base) Returns the number in another base printing out entire bytes. 42 toBaseWholeBytes(2) -> \"00101010\"\n"
  	"        toBaseWholeBytes := method(base,\n"
  	"            str := self asString toBase(base)\n"
  	"            byteColumns := 256 log(base) ceil\n"
  	"            alignedWidth := (str size / byteColumns) ceil * byteColumns\n"
  	"            str alignRight(alignedWidth, \"0\")\n"
  	"        )\n"
  	"\n"
  	"	//doc Number asHex Returns the number as hex digits inside a string. 97 asHex -> \"61\"\n"
  	"	asHex := method(toBaseWholeBytes(16))\n"
  	"\n"
  	"	//doc Number asBinary Returns the number as binary digits inside a string. 42 asBinary -> \"101010\"\n"
  	"	asBinary := method(toBaseWholeBytes(2))\n"
  	"\n"
  	"	//doc Number asOctal Returns the number as octal digits inside a string. 436 asOctal -> \"664\"\n"
  	"	asOctal := method(toBaseWholeBytes(8))\n"
  	"\n"
  	"	//doc Number combinations(size) Returns the combinations where the receiver is the number of different objects and size is the number to be arranged.\n"
  	"	combinations := method(r, self factorial /(r factorial *((self - r) factorial)))\n"
  	"\n"
  	"	//doc Number permutations(size) Returns the permutations where the receiver is the number of different objects and size is the number to be arranged.\n"
  	"	permutations := method(r, self factorial /((self - r) factorial))\n"
  	"\n"
  	"	//doc Number minMax(low, high) Returns a number between or equal to low and high. If the receiver is equal to or between low and high, the receiver is returned. If the receiver is less than low, low is returned. If the receiver is greater than high, high is returned.\n"
  	"	minMax := method(low, high, min(high) max(low))\n"
  	"	\n"
  	"	asJson := getSlot(\"asString\")\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "Number.io");

	s = "Block printProfile := method(\n"
  	"	m := getSlot(\"self\") message\n"
  	"	writeln(\"  \", getSlot(\"self\") profilerTime asString(0,6), \"s in Block (\", getSlot(\"self\") argumentNames join(\",\"), \") \", m label, \" \", m lineNumber)\n"
  	")\n"
  	"\n"
  	"Core getSlot(\"CFunction\") printProfile := method(\n"
  	"	writeln(\"  \", getSlot(\"self\") profilerTime asString(0,6), \"s in CFunction \", getSlot(\"self\") uniqueName, \"()\")\n"
  	"	\n"
  	")\n"
  	"\n"
  	"Profiler do(\n"
  	"	start := method(\n"
  	"		self reset\n"
  	"		Block setProfilerOn(true)\n"
  	"		//CFunction setProfilerOn(true)\n"
  	"		Core getSlot(\"CFunction\") setProfilerOn(true)\n"
  	"		self\n"
  	"	)\n"
  	"	\n"
  	"	stop := method(\n"
  	"		Block setProfilerOn(false)\n"
  	"		//CFunction setProfilerOn(false)\n"
  	"		Core getSlot(\"CFunction\") setProfilerOn(false)\n"
  	"		self\n"
  	"	)\n"
  	"	\n"
  	"	show := method(\n"
  	"		writeln(\"\\nProfile:\")\n"
  	"		blocks := self timedObjects select(b, getSlot(\"b\") type == \"Block\") // or getSlot(\"b\") type == \"CFunction\")\n"
  	"		blocks := blocks map(b, \n"
  	"			o := Object clone\n"
  	"			o newSlot(\"b\", getSlot(\"b\"))\n"
  	"			o newSlot(\"profilerTime\", getSlot(\"b\") profilerTime) \n"
  	"			o\n"
  	"		) \n"
  	"		blocks := blocks sortByKey(profilerTime) reverse select(profilerTime > 0)\n"
  	"		if(blocks size == 0, \n"
  	"			writeln(\"  sample size to small\")\n"
  	"		,\n"
  	"			maxTime := blocks first profilerTime\n"
  	"			blocks foreach(b,\n"
  	"				b getSlot(\"b\") printProfile\n"
  	"				if(b profilerTime < maxTime/100, break)\n"
  	"			)\n"
  	"		)\n"
  	"		writeln(\"\")\n"
  	"	)\n"
  	"	\n"
  	"	profile := method(\n"
  	"		start\n"
  	"		call evalArgAt(0)\n"
  	"		stop\n"
  	"		show\n"
  	"	)\n"
  	"	\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "Profiler.io");

	s = "Sandbox do(\n"
  	"	//doc Sandbox printCallback(string) default implementation is; method(string, string print)\n"
  	"	printCallback := method(string, string print)\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "Sandbox.io");

	s = "\n"
  	"//doc nil justSerialized(stream) Writes the receiver's code into the stream.\n"
  	"//doc true justSerialized(stream) Writes the receiver's code into the stream.\n"
  	"//doc false justSerialized(stream) Writes the receiver's code into the stream.\n"
  	"\n"
  	"nil   justSerialized := method(stream, stream write(\"nil\"))\n"
  	"true  justSerialized := method(stream, stream write(\"true\"))\n"
  	"false justSerialized := method(stream, stream write(\"false\"))\n"
  	"\n"
  	"//doc Number justSerialized(stream) Writes the receiver's code into the stream.\n"
  	"Number justSerialized := method(stream,\n"
  	"	stream write(self asSimpleString)\n"
  	")\n"
  	"\n"
  	"//doc Sequence justSerialized(stream) Writes the receiver's code into the stream.\n"
  	"Sequence justSerialized := method(stream,\n"
  	"	stream write(self asMutable escape asSimpleString)\n"
  	")\n"
  	"\n"
  	"//doc List justSerialized(stream) Writes the receiver's code into the stream.\n"
  	"List justSerialized := method(stream,\n"
  	"	stream write(\"list(\")\n"
  	"	stream write(self map(serialized) join(\", \"))\n"
  	"	stream write(\");\")\n"
  	")\n"
  	"\n"
  	"//doc Map justSerialized(stream) Writes the receiver's code into the stream.\n"
  	"Map justSerialized := method(stream,\n"
  	"	stream write(\"Map clone do(\")\n"
  	"	self foreach(k, v,\n"
  	"		stream write(\"atPut(\" .. k serialized .. \", \" .. getSlot(\"v\") serialized .. \");\")\n"
  	"	)\n"
  	"	stream write(\");\")\n"
  	")\n"
  	"\n"
  	"//doc Block justSerialized(stream) Writes the receiver's code into the stream.\n"
  	"Block justSerialized := method(stream,\n"
  	"		stream write(code, \"\\n\")\n"
  	")\n"
  	"\n"
  	"SerializationStream := Object clone do(\n"
  	"	init := method(\n"
  	"		self seen := Map clone\n"
  	"		self output := Sequence clone\n"
  	"	)\n"
  	"\n"
  	"	write := method(\n"
  	"		for(i, 0, call argCount - 1,\n"
  	"			//super(writeln(i, call argAt(i)))\n"
  	"			output appendSeq(call evalArgAt(i))\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"  /*doc Object serialized\n"
  	"  Returns a serialized representation of the receiver.\n"
  	"  <br/>\n"
  	"  <pre>\n"
  	"  Io> Object clone do(x:=1) serialized\n"
  	"  ==> Object clone do(\n"
  	"  	x := 1\n"
  	"  )\n"
  	"  </pre>\n"
  	"  */\n"
  	"	serialized := method(stream,\n"
  	"		if(stream == nil, stream := SerializationStream clone)\n"
  	"		justSerialized(stream)\n"
  	"		stream output\n"
  	"	)\n"
  	"  \n"
  	"  /*doc Object justSerialized(stream)\n"
  	"  Writes serialized representation to a SerializationStream. Returns stream contents. \n"
  	"  [This is unintended side effect! Returned value may change in the future.]\n"
  	"  */\n"
  	"	justSerialized := method(stream,\n"
  	"		stream write(\n"
  	"			if(getSlot(\"self\") hasLocalSlot(\"type\"),\n"
  	"				getSlot(\"self\") proto type\n"
  	"			,\n"
  	"				getSlot(\"self\") type\n"
  	"			)\n"
  	"		, \" clone do(\\n\")\n"
  	"		self serializedSlots(stream)\n"
  	"		stream write(\")\\n\")\n"
  	"	)\n"
  	"\n"
  	"  //doc Object serializedSlots(stream) Writes all slots to a stream.\n"
  	"	serializedSlots := method(stream,\n"
  	"		self serializedSlotsWithNames(self slotNames, stream)\n"
  	"	)\n"
  	"\n"
  	"  //doc Object serializedSlotsWithNames(names, stream) Writes selected slots to a stream.\n"
  	"	serializedSlotsWithNames := method(names, stream,\n"
  	"		names foreach(slotName,\n"
  	"			stream write(\"\\t\", slotName, \" := \")\n"
  	"			self getSlot(slotName) serialized(stream)\n"
  	"			stream write(\"\\n\")\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "Serialize.io");

	s = "System do(\n"
  	"	args := list()\n"
  	"	\n"
  	"	launchScript := nil\n"
  	"	//doc System launchScript Returns the path of the io file run on the command line. Returns nil if no file was run.\n"
  	"\n"
  	"	ioPath := installPrefix asMutable appendPathSeq(\"lib\") appendPathSeq(\"io\")\n"
  	"	//doc System ioPath Returns the path of io installation. The default is $INSTALL_PREFIX/lib/io.\n"
  	"\n"
  	"	/*doc System getOptions(args) \n"
  	"	This primitive is used to get command line options similar to Cs getopt().\n"
  	"	It returns a map in containing the left side of the argument, with the\n"
  	"	value of the right side. (The key will not contain\n"
  	"	the beginning dashes (--).\n"
  	"	<p>\n"
  	"	Example:\n"
  	"	<pre>\n"
  	"	options := System getOptions(args)\n"
  	"	options foreach(k, v,\n"
  	"	  if(v type == List type,\n"
  	"		v foreach(i, j, writeln(\\\"Got unnamed argument with value: \\\" .. j))\n"
  	"		continue\n"
  	"	  )\n"
  	"	  writeln(\\\"Got option: \\\" .. k .. \\\" with value: \\\" .. v)\n"
  	"	)\n"
  	"	</pre>\n"
  	"	*/\n"
  	"\n"
  	"	getOptions := method(arguments,\n"
  	"		opts := Map clone\n"
  	"		optname := Sequence clone\n"
  	"		optvalue := Sequence clone\n"
  	"		optsNoKey := List clone\n"
  	"\n"
  	"		arguments foreach(i, arg,\n"
  	"			if(not(arg beginsWithSeq(\"--\")),\n"
  	"				optsNoKey append(arg)\n"
  	"				continue\n"
  	"			)\n"
  	"\n"
  	"			if(arg containsSeq(\"=\")) then(\n"
  	"				optname := arg clone asMutable\n"
  	"				optname clipAfterStartOfSeq(\"=\")\n"
  	"				optname clipBeforeEndOfSeq(\"--\")\n"
  	"				optvalue := arg clone asMutable\n"
  	"				optvalue clipBeforeEndOfSeq(\"=\")\n"
  	"			) else(\n"
  	"				optname := arg clone asMutable\n"
  	"				optname clipBeforeEndOfSeq(\"--\")\n"
  	"				optvalue = \"\"\n"
  	"			)\n"
  	"			opts atPut(optname, optvalue)\n"
  	"		)\n"
  	"\n"
  	"		if(optsNoKey last != nil, opts atPut(\"\", optsNoKey))\n"
  	"		opts\n"
  	"	)\n"
  	"\n"
  	"	//doc System userInterruptHandler Called when control-c is hit. Override to add custom behavior. Returns self.\n"
  	"	userInterruptHandler := method(\n"
  	"		writeln(\"\\n  current coroutine\")\n"
  	"		Scheduler currentCoroutine showStack\n"
  	"		Scheduler yieldingCoros foreach(coro,\n"
  	"			writeln(\"  coroutine \", coro label)\n"
  	"			coro showStack\n"
  	"		)\n"
  	"		self exit\n"
  	"	)\n"
  	"	\n"
  	"	//doc System runCommand Calls system and redirects stdout/err to tmp files.  Returns object with exitStatus, stdout and stderr slots.\n"
  	"	runCommand := method(cmd, successStatus,\n"
  	"		successStatus := if(successStatus, successStatus, 0)\n"
  	"		tmpDirPath := System getEnvironmentVariable(\"TMPDIR\")\n"
  	"		outPath := method(suffix,\n"
  	"			Path with(tmpDirPath, list(System thisProcessPid, Date clone now asNumber, suffix) join(\"-\"))\n"
  	"		)\n"
  	"		stdoutPath := outPath(\"stdout\")\n"
  	"		stderrPath := outPath(\"stderr\")\n"
  	"		exitStatus := System system(cmd .. \" > \" .. stdoutPath .. \" 2> \" .. stderrPath)\n"
  	"		result := Object clone\n"
  	"		result successStatus := successStatus\n"
  	"		result exitStatus := exitStatus\n"
  	"		result failed := method(exitStatus != successStatus)\n"
  	"		result succeeded := method(exitStatus == successStatus)\n"
  	"		result stdout := File with(stdoutPath) contents\n"
  	"		result stderr := File with(stderrPath) contents\n"
  	"		result\n"
  	"	)\n"
  	"	\n"
  	"\n"
  	"	//doc System iospecVersion The version of IoSpec our IoVM is compatible with\n"
  	"	iospecVersion := \"0.1.0\"\n"
  	"\n"
  	"	//doc System iovmName The name of our IoVM as used by IoSpec\n"
  	"	iovmName := \"iolanguage\"\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "System.io");

	s = "//metadoc UnitTest category Testing\n"
  	"/*metadoc UnitTest description\n"
  	"An object for organizing and running unit tests validated by assertions.\n"
  	"*/\n"
  	"\n"
  	"//metadoc TestRunner category Testing\n"
  	"/*metadoc TestRunner description\n"
  	"Core testing object responsible for running tests, collected by UnitTests and TestSuites.\n"
  	"*/\n"
  	"TestRunner := Object clone do(\n"
  	"    width ::= 70 # Line width.\n"
  	"\n"
  	"    init := method(\n"
  	"        self cases := nil\n"
  	"        self exceptions := List clone\n"
  	"        self runtime := 0\n"
  	"    )\n"
  	"//doc TestRunner testCount Returns the number of tests to be ran.\n"
  	"    testCount := method(\n"
  	"        self cases values prepend(0) reduce(\n"
  	"            count, testSlotNames, count + testSlotNames size\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"//doc TestRunner name Returns the name of the TestRunner.\n"
  	"    name := method(\n"
  	"        # If we are running a single test, the the test's name\n"
  	"        # is taken as TestRunner's name, else processed file\n"
  	"        # name is returned.\n"
  	"        if(self cases size > 1,\n"
  	"            System launchScript fileName\n"
  	"        ,\n"
  	"            if(self cases size > 0, self cases keys first, \"\")\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"    linebreak := method(\n"
  	"        if(self ?dots,\n"
  	"            self dots = self dots + 1\n"
  	"         ,\n"
  	"            self dots := 1)\n"
  	"        # Break the line, when the number of dots exceed the\n"
  	"        # predefined line width.\n"
  	"        if(self dots % width == 0, \"\\n\" print)\n"
  	"\n"
  	"    )\n"
  	"    success := method(\n"
  	"        \".\" print\n"
  	"        linebreak\n"
  	"    )\n"
  	"    error := method(name, exc,\n"
  	"        # We need to store both the name of the failed slot and\n"
  	"        # the exception occured, so that we can output them together\n"
  	"        # later on.\n"
  	"        self exceptions append(list(name, exc))\n"
  	"        \"E\" print\n"
  	"        linebreak\n"
  	"    )\n"
  	"\n"
  	"/*doc TestRunner run(testMap)\n"
  	"Runs all tests from a given Map object, where keys are names of the UnitTests\n"
  	"to run and values - lists of test slots theese UnitTests provide.*/\n"
  	"    run := method(testMap,\n"
  	"        self cases := testMap # Storing a reference to the test map.\n"
  	"        self runtime := Date secondsToRun(\n"
  	"            testMap foreach(testCaseName, testSlotNames,\n"
  	"                # Depending on the Lobby is kind of wacky, but that's\n"
  	"                # all we can do, since Map only supports string keys.\n"
  	"                testCase := Lobby getSlot(testCaseName)\n"
  	"                testSlotNames foreach(name,\n"
  	"                    testCase setUp\n"
  	"                    exc := try(stopStatus(testCase doString(name)))\n"
  	"                    if(exc, error(testCaseName .. \" \" .. name, exc), success)\n"
  	"                    testCase tearDown\n"
  	"                )\n"
  	"            )\n"
  	"        )\n"
  	"\n"
  	"        printExceptions\n"
  	"        printSummary\n"
  	"    )\n"
  	"\n"
  	"    printExceptions := method(\n"
  	"        \"\\n\" print\n"
  	"\n"
  	"        # Printing exceptions in the order they occured.\n"
  	"        exceptions foreach(exc,\n"
  	"            (\"=\" repeated(width) .. \"\\nFAIL: \" .. exc at(0) .. \\\n"
  	"             \"\\n\" .. \"-\" repeated(width)) println\n"
  	"            exc at(1) showStack\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"    printSummary := method(\n"
  	"        \"-\" repeated(width) println\n"
  	"        (\"Ran \" .. testCount .. \" test\" .. if(testCount != 1, \"s\", \"\") .. \\\n"
  	"         \" in \" .. runtime .. \"s\\n\") println\n"
  	"\n"
  	"        result := if(exceptions isNotEmpty,\n"
  	"            \"FAILED (failures #{exceptions size})\" interpolate\n"
  	"        ,\n"
  	"            \"OK\")\n"
  	"\n"
  	"        (result .. name alignRight(width - result size) .. \"\\n\") println\n"
  	"    )\n"
  	")\n"
  	"\n"
  	"# A mix-in object, allowing the collectors to run the collected\n"
  	"# tests. Merely a shortcut, since nobody wants to write two lines\n"
  	"# instead of a single word :)\n"
  	"RunnerMixIn := Object clone do(\n"
  	"    run := method(\n"
  	"        TestRunner clone run(prepare)\n"
  	"    )\n"
  	")\n"
  	"\n"
  	"//doc UnitTest setUp Method called prior to each test.\n"
  	"//doc UnitTest tearDown Method called after each test.\n"
  	"//doc UnitTest fail(error) Call to trigger a test failure with a given error message.\n"
  	"UnitTest := Object clone prependProto(RunnerMixIn) do(\n"
  	"    setUp := method(nil)\n"
  	"    tearDown := method(nil)\n"
  	"\n"
  	"    testSlotNames := method(\n"
  	"        names := self slotNames select(beginsWithSeq(\"test\"))\n"
  	"        if(names isEmpty,\n"
  	"            names\n"
  	"        ,\n"
  	"            names sortByKey(name, self getSlot(name) message lineNumber)\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"    prepare := method(Map with(self type, testSlotNames))\n"
  	"\n"
  	"    fail := method(error,\n"
  	"        Exception raise(\n"
  	"            if(error, error, \"fail\")\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"//doc UnitTest assertEquals(a, b) Fail the running test if a != b.\n"
  	"//doc UnitTest assertNotEquals(a, b) Fail the running test if a == b.\n"
  	"//doc UnitTest assertNotSame(a, b) Fail the running test if a != b.\n"
  	"//doc UnitTest assertNil(a) Fail the running test if a != nil.\n"
  	"//doc UnitTest assertNotNil(a) Fail the running test if a == nil.\n"
  	"//doc UnitTest assertTrue(a) Fail the running test if a != true.\n"
  	"//doc UnitTest assertFalse(a) Fail the running test if a != false.\n"
  	"//doc UnitTest assertRaisesException(code) Fail the running test if the code does not raise an Exception.\n"
  	"/*doc UnitTest assertEqualsWithinDelta(expected, actual, delta)\n"
  	"Fail the running test if the expected value is not within delta of the actual value.\n"
  	"*/\n"
  	"    assertEquals := method(a, b, m,\n"
  	"        m ifNil(m = call message)\n"
  	"        if(a != b,\n"
  	"            # Since Message asString is the same as Message code,\n"
  	"            # we don't have to access the latter excplitly inside\n"
  	"            # the interpolated string.\n"
  	"            fail(\n"
  	"                (\"`#{ m argAt(0) } != #{ m argAt(1) }` --> \" .. \\\n"
  	"                 \"`#{ a asSimpleString } != #{ b asSimpleString }`\") interpolate\n"
  	"            )\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"    assertNotEquals := method(a, b, m,\n"
  	"        m ifNil(m = call message)\n"
  	"        if(a == b,\n"
  	"            fail(\n"
  	"                (\"`#{ m argAt(0) } == #{ m argAt(1) }` --> \" .. \\\n"
  	"                 \"`#{ a asSimpleString } == #{ b asSimpleString }`\") interpolate\n"
  	"            )\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"    assertSame    := method(a, b, assertEquals(a uniqueId, b uniqueId, call message))\n"
  	"    assertNotSame := method(a, b, assertNotEquals(a uniqueId, b uniqueId, call message))\n"
  	"    assertNil     := method(a, assertEquals(a, nil, call message))\n"
  	"    assertNotNil  := method(a, assertNotEquals(a, nil, call message))\n"
  	"    assertTrue    := method(a, assertEquals(a, true, call message))\n"
  	"    assertFalse   := method(a, assertEquals(a, false, call message))\n"
  	"\n"
  	"    assertRaisesException := method(\n"
  	"        try(call evalArgAt(0)) ifNil(\n"
  	"            fail(\"`#{call argAt(0)}` should have raised Exception\" interpolate)\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"    knownBug := method(\n"
  	"        # Probably this should be a special case of assertEquals, so\n"
  	"        # you can be sure that the bug still exists.\n"
  	"        fail(\"`#{call argAt(0)}` is a known bug\" interpolate)\n"
  	"    )\n"
  	"\n"
  	"    # Rename this method to assertAlmostEquals?\n"
  	"    assertEqualsWithinDelta := method(expected, actual, delta,\n"
  	"        if(((expected - actual) abs > delta),\n"
  	"            fail(\"#{expected} expected, but was #{actual} (allowed delta: #{delta})\")\n"
  	"        )\n"
  	"    )\n"
  	")\n"
  	"\n"
  	"//metadoc DirectoryCollector category Testing\n"
  	"/*metadoc DirectoryCollector description\n"
  	"An object to collect multiple UnitTests defined in *Test.io files within a given directory (System launchPath directory by default).\n"
  	"*/\n"
  	"DirectoryCollector := Object clone prependProto(RunnerMixIn) do(\n"
  	"    path ::= lazySlot(System launchPath)\n"
  	"\n"
  	"//doc DirectoryCollector with(aPath) Returns a new instance with the provided path.\n"
  	"    with := method(path, self clone setPath(path))\n"
  	"\n"
  	"    testFiles := method(\n"
  	"        Directory with(path) files select(name endsWithSeq(\"Test.io\"))\n"
  	"    )\n"
  	"\n"
  	"    prepare := method(\n"
  	"        # Importing all test files in the set up path to the global namespace.\n"
  	"        testFiles foreach(file,\n"
  	"            # Note: second argument is a label.\n"
  	"            Lobby doString(file contents, file path)\n"
  	"        )\n"
  	"\n"
  	"        FileCollector prepare\n"
  	"    )\n"
  	")\n"
  	"\n"
  	"//metadoc FileCollector category Testing\n"
  	"/*metadoc FileCollector description\n"
  	"An object to collect multiple UnitTests defined in the current file.\n"
  	"*/\n"
  	"FileCollector := Object clone prependProto(RunnerMixIn) do(\n"
  	"    prepare := method(\n"
  	"        cases := Map clone\n"
  	"\n"
  	"        # Iterating over all of the imported objects and collecting\n"
  	"        # UnitTest instances. Since Block objects doesn't respond\n"
  	"        # correctly to isKindOf, we need to filter out all activatable\n"
  	"        # objects first and only then check for the type (kind).\n"
  	"        Lobby foreachSlot(slotName, slotValue,\n"
  	"            if(getSlot(\"slotValue\") isActivatable not and \\\n"
  	"               slotValue isKindOf(UnitTest),\n"
  	"                cases mergeInPlace(slotValue prepare)\n"
  	"            )\n"
  	"        )\n"
  	"        cases\n"
  	"    )\n"
  	")\n"
  	"\n"
  	"# For backward compatibility.\n"
  	"TestSuite := getSlot(\"DirectoryCollector\")";

    IoState_rawOn_doCString_withLabel_(self, context, s, "UnitTest.io");

	s = "Sequence do(\n"
  	"	x := method(at(0))\n"
  	"	y := method(at(1))\n"
  	"	z := method(at(2))\n"
  	"	setX := method(a, atPut(0, a); self)\n"
  	"	setY := method(a, atPut(1, a); self)\n"
  	"	setZ := method(a, atPut(2, a); self)\n"
  	"	set := method(call evalArgs foreach(i, v, atPut(i, v)))\n"
  	"	rootMeanSquare := method(meanSquare sqrt)\n"
  	")\n"
  	"\n"
  	"Sequence addEquals := Sequence getSlot(\"+=\")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "Vector.io");

	s = "tildeExpandsTo := method(\n"
  	"    platform := System platform\n"
  	"\n"
  	"    if(platform == \"windows\" or platform == \"mingw\",\n"
  	"        # Windows\n"
  	"        System getEnvironmentVariable(\"UserProfile\"),\n"
  	"\n"
  	"        # Unix\n"
  	"        System getEnvironmentVariable(\"HOME\")\n"
  	"    )\n"
  	")\n"
  	"\n"
  	"Sequence stringByExpandingTilde := method(\n"
  	"	self split(\"~\") join(tildeExpandsTo())\n"
  	")\n"
  	"\n"
  	"Path := Object clone do(\n"
  	"	//metadoc Path category FileSystem\n"
  	"\n"
  	"	//doc Path hasDriveLetters returns true if the platform requires DOS C: style drive letters.\n"
  	"	hasDriveLetters := System platform containsAnyCaseSeq(\"Windows\") or System platform containsAnyCaseSeq(\"Cygwin\") or System platform containsAnyCaseSeq(\"mingw\")\n"
  	"\n"
  	"	//doc Path with(aSequence) Returns a new Path object for the given Sequence.\n"
  	"	with := method(\n"
  	"		s := Sequence clone\n"
  	"		call message arguments foreach(arg,\n"
  	"			v := call sender doMessage(arg)\n"
  	"			//writeln(\"appendPathSeq(\", v type, \")\")\n"
  	"			if(v != nil, \n"
  	"				s appendPathSeq(v)\n"
  	"			)\n"
  	"		)\n"
  	"		s asSymbol\n"
  	"	)\n"
  	"\n"
  	"	//doc Path isPathAbsolute Returns true if path is absolute, false if it is relative.\n"
  	"	isPathAbsolute := method(p,\n"
  	"		if(p == nil or p size == 0, return false)\n"
  	"		\n"
  	"		absolute := false\n"
  	"		//try (\n"
  	"			if (hasDriveLetters,\n"
  	"				absolute = p at(0) isLetter and p at(1) asCharacter == \":\" or p at(0) asCharacter == \"/\" or p at(0) asCharacter == \"\\\\\"\n"
  	"			,\n"
  	"				absolute = p at(0) asCharacter == \"/\"\n"
  	"			)\n"
  	"		//)\n"
  	"		absolute\n"
  	"	)\n"
  	"\n"
  	"	//doc Path absolute Returns an absolute version of the path.\n"
  	"	absolute := method(path,\n"
  	"		path := path stringByExpandingTilde\n"
  	"\n"
  	"		if(isPathAbsolute(path),\n"
  	"			path\n"
  	"		,\n"
  	"			with(Directory currentWorkingDirectory, path)\n"
  	"		)\n"
  	"	)\n"
  	"	\n"
  	"	//doc Path thisSourceFilePath Uses call message label to return an absolute path to the file that contains the sender.\n"
  	"	thisSourceFilePath := method(\n"
  	"		Path absolute(call message label)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "Y_Path.io");

	s = "Locals removeSlot(\"doFile\")\n"
  	"\n"
  	"DummyLine := File standardInput do(\n"
  	"    readLine := method(prompt,\n"
  	"        if(prompt, prompt print)\n"
  	"        resend\n"
  	"    )\n"
  	")\n"
  	"\n"
  	"CLI := Object clone do(\n"
  	"    prompt ::= \"Io> \"\n"
  	"    outPrompt ::= \"==> \"\n"
  	"    continuedLinePrompt ::= \"... \"\n"
  	"\n"
  	"    isRunning ::= true # Get rid of this ...\n"
  	"    commandLineLabel ::= \"Command Line\" # and this?\n"
  	"\n"
  	"    context ::= lazySlot(\n"
  	"        Lobby do(\n"
  	"            # Python-style underscore, stores the result of the previous computation.\n"
  	"            # Example:\n"
  	"            # Io> 1 + 1\n"
  	"            # ==> 2\n"
  	"            # Io> _ == 2\n"
  	"            # ==> true\n"
  	"            _ ::= nil\n"
  	"\n"
  	"            exit := method(CLI stop)\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"    lineReader := lazySlot(\n"
  	"        # This might look as a `hack`, but why not use stdin as the default\n"
  	"        # reader, since it shares the same interface with Read(Edit)Line,\n"
  	"        # i.e. <reader> readLine.\n"
  	"        reader := DummyLine\n"
  	"\n"
  	"        # Trying to use GNU ReadLine as the default line reader, falling\n"
  	"        # back to EditLine, if the attempt failed.\n"
  	"        try(reader := ReadLine) catch(Exception,\n"
  	"            try(reader := EditLine)\n"
  	"        )\n"
  	"        reader\n"
  	"    )\n"
  	"\n"
  	"    # A list of error messages for the errors we understand.\n"
  	"    knownErrors := lazySlot(\n"
  	"        list(\"(\", \"[\", \"{\", \"\\\"\\\"\\\"\", \"(x,\") map(error,\n"
  	"            self errorMessage(try(error asMessage) error)\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"    errorMessage := method(error, error beforeSeq(\" on line\"))\n"
  	"\n"
  	"    doFile := method(path,\n"
  	"        System launchPath = if(Path isPathAbsolute(path),\n"
  	"            path\n"
  	"        ,\n"
  	"            System launchPath asMutable appendPathSeq(path)\n"
  	"        ) pathComponent\n"
  	"\n"
  	"        System launchScript = path\n"
  	"\n"
  	"        context doFile(path)\n"
  	"    )\n"
  	"\n"
  	"    doLine := method(lineAsMessage,\n"
  	"        # Execute the line and report any exceptions which happened.\n"
  	"        executionError := try(result := context doMessage(lineAsMessage))\n"
  	"        if(executionError,\n"
  	"            executionError showStack\n"
  	"        ,\n"
  	"            # Write out the command's result to stdout; nothing is written\n"
  	"            # if the CLI is terminated, this condition is satisfied, only\n"
  	"            # when CLI exit() was called.\n"
  	"            if(isRunning,\n"
  	"                context set_(getSlot(\"result\"))\n"
  	"                writeCommandResult(getSlot(\"result\")))\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"    doIorc := method(\n"
  	"        # Note: Probably won't work on Windows, since it uses %HOMEPATH%\n"
  	"        # and %HOMEDRIVE% pair to indentify user's home directory.\n"
  	"        home := System getEnvironmentVariable(\"HOME\")\n"
  	"        if(home,\n"
  	"            path := Path with(home, \".iorc\")\n"
  	"            if(File with(path) exists,\n"
  	"                context doFile(path)\n"
  	"            )\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"    ioHistoryFile := lazySlot(\n"
  	"        Path with(System getEnvironmentVariable(\"HOME\"), \".io_history\")\n"
  	"    )\n"
  	"\n"
  	"    saveHistory := method(lineReader ?saveHistory(ioHistoryFile))\n"
  	"    loadHistory := method(\n"
  	"        if(File with(ioHistoryFile) exists,\n"
  	"            lineReader ?loadHistory(ioHistoryFile)\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"\n"
  	"    writeWelcomeBanner := method(\"Io #{System version}\" interpolate println)\n"
  	"    writeCommandResult := method(result,\n"
  	"        outPrompt print\n"
  	"\n"
  	"        if(exc := try(getSlot(\"result\") asString println),\n"
  	"            \"<exception while dislaying result>\" println\n"
  	"            exc showStack\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"    stop := method(setIsRunning(false))\n"
  	"    run  := method(\n"
  	"        Importer addSearchPath(\n"
  	"            System launchPath := Directory currentWorkingDirectory\n"
  	"        )\n"
  	"\n"
  	"        doIorc\n"
  	"\n"
  	"        # Note: GetOpt should be used there, since System getOptions\n"
  	"        # is completely useless.\n"
  	"        if(\"-h\" in(System args) and System args size == 1, help)\n"
  	"        if(\"--version\" in (System args) and System args size == 1, version) # hm...\n"
  	"\n"
  	"        if(System args first == \"-e\") then(\n"
  	"            return context doString(\n"
  	"                System args slice(1) map(asUTF8) join(\" \")\n"
  	"            )\n"
  	"        ) elseif(System args first == \"-i\" and System args size >= 2) then(\n"
  	"            # Note: when given an -i option, all the following arguments\n"
  	"            # should be filenames to be loaded into the REPL.\n"
  	"            System args rest foreach(arg,\n"
  	"                doFile(arg)\n"
  	"            )\n"
  	"        ) elseif(System args size > 0,\n"
  	"            return doFile(System args first)\n"
  	"        )\n"
  	"\n"
  	"        # Is this still needed? Not used anywhere in the source.\n"
  	"        if(File clone setPath(\"main.io\") exists,\n"
  	"            doFile(\"main.io\")\n"
  	"        )\n"
  	"\n"
  	"        loadHistory\n"
  	"        writeWelcomeBanner\n"
  	"        interactive\n"
  	"        saveHistory\n"
  	"    )\n"
  	"\n"
  	"    interactive := method(\n"
  	"        # Start with the default prompt. The prompt is changed for continued lines,\n"
  	"        # and errors.\n"
  	"        prompt := self prompt\n"
  	"        line := \"\"\n"
  	"\n"
  	"        # If there are unmatched (, {, [ or the command ends with a \\ then we'll\n"
  	"        # need to read multiple lines.\n"
  	"        loop(\n"
  	"            # Write out prompt and read line.\n"
  	"            if(nextLine := lineReader readLine(prompt),\n"
  	"                # Add what we read to the line we've been building up\n"
  	"                line = line .. nextLine\n"
  	"            ,\n"
  	"                # Note: readLine method returns nil if ^D was pressed.\n"
  	"                context exit\n"
  	"                \"\\n\" print # Fixing the newline issue.\n"
  	"            )\n"
  	"\n"
  	"            compileError := try(\n"
  	"                lineAsMessage := line asMessage setLabel(commandLineLabel)\n"
  	"            )\n"
  	"\n"
  	"            if(compileError,\n"
  	"                # Not sure that, displaying a different notification for\n"
  	"                # each error actually makes sense.\n"
  	"                if(nextLine size > 0 and errorMessage(compileError error) in(knownErrors),\n"
  	"                    prompt = continuedLinePrompt\n"
  	"                    continue\n"
  	"                )\n"
  	"                # If the error can't be fixed by continuing the line - report it.\n"
  	"                compileError showStack\n"
  	"            ,\n"
  	"                doLine(lineAsMessage)\n"
  	"            )\n"
  	"\n"
  	"            lineReader ?addHistory(line)\n"
  	"            return if(isRunning, interactive, nil)\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"    version := inlineMethod(\n"
  	"        \"Io Programming Language, v. #{System version}\" interpolate println;\n"
  	"        System exit\n"
  	"    )\n"
  	"\n"
  	"    help := inlineMethod(\n"
  	"\"\"\"\n"
  	"usage: io [-h | -e expr | -i file.io, file.io, ...| file.io arg, arg, ... | --version]\n"
  	"\n"
  	"options:\n"
  	"  --version   print the version of the interpreter and exit\n"
  	"  -h          print this help message and exit\n"
  	"  -e          eval a given expression and exit\n"
  	"  -i          run the interpreter, after processing the files passed\n"
  	"\n"
  	"\"\"\" println\n"
  	"        System exit\n"
  	"    )\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "Z_CLI.io");

	s = "Importer := Object clone do(\n"
  	"	//metadoc Importer description A simple search path based auto-importer.\n"
  	"\n"
  	"	//doc Importer paths List of paths the proto importer will check while searching for protos to load.\n"
  	"	paths := method(FileImporter directories)\n"
  	"\n"
  	"	//doc Importer addSearchPath(path) Add a search path to the auto importer. Relative paths are made absolute before adding.\n"
  	"	addSearchPath := method(p, paths appendIfAbsent(Path absolute(p) asSymbol))\n"
  	"\n"
  	"	//doc Importer removeSearchPath(path) Removes a search path from the auto importer. Relative paths should be removed from the same working directory as they were added.\n"
  	"	removeSearchPath := method(p, paths remove(Path absolute(p) asSymbol))\n"
  	"\n"
  	"	//doc Importer FileImporter An Importer for local source files.\n"
  	"	FileImporter := Object clone do(\n"
  	"		importsFrom := \"file\"\n"
  	"\n"
  	"		directories := list(\"\")\n"
  	"\n"
  	"		import := method(protoName, originalCall,\n"
  	"			if(System ?launchPath, directories appendIfAbsent(System launchPath))\n"
  	"			if(System getEnvironmentVariable(\"IOIMPORT\"),\n"
  	"				ioImportEnv := System getEnvironmentVariable(\"IOIMPORT\")\n"
  	"				if(System platform == \"Windows\",\n"
  	"					ioImportEnv split(\";\") foreach(p,\n"
  	"						directories appendIfAbsent(Path absolute(p) asSymbol)\n"
  	"					)\n"
  	"				,\n"
  	"					ioImportEnv split(\":\") foreach(p,\n"
  	"						directories appendIfAbsent(Path absolute(p) asSymbol)\n"
  	"					)\n"
  	"				)\n"
  	"			)\n"
  	"\n"
  	"			directories foreach(folder,\n"
  	"				if(tryToImportProtoFromFolder(protoName, folder, originalCall), return true)\n"
  	"			)\n"
  	"			false\n"
  	"		)\n"
  	"\n"
  	"\n"
  	"		//doc FileImporter ioFileSuffixes A list of valid io source file suffixes. \n"
  	"		ioFileSuffixes ::= list(\"io\", \"ioe\")\n"
  	"\n"
  	"		//doc FileImporter tryToImportProtoFromFolder(protoName, path) Looks for the protoName with the valid ioFileSuffixes and calls importPath if found.\n"
  	"		tryToImportProtoFromFolder := method(protoName, folder, originalCall,\n"
  	"			importedFrom := Path absolute(originalCall message label) asMutable lowercase\n"
  	"\n"
  	"			ioFileSuffixes foreach(suffix,\n"
  	"				path := Path with(folder, protoName .. \".\" .. suffix) asSymbol\n"
  	"				normalized := Path absolute(path) asMutable lowercase\n"
  	"\n"
  	"				// skip file in which 'import' was called\n"
  	"				if(normalized == importedFrom,\n"
  	"					continue\n"
  	"				)\n"
  	"\n"
  	"				//writeln(\"looking for \", path)\n"
  	"				if(File with(path) exists,\n"
  	"					return importPath(path)\n"
  	"				)\n"
  	"			)\n"
  	"			false\n"
  	"		)\n"
  	"\n"
  	"		key := \"deafultKey\"\n"
  	"\n"
  	"		//doc FileImporter importPath(path) Performs Lobby doFile(path). Can override to deal with other formats.\n"
  	"		importPath := method(path,\n"
  	"			//writeln(\"importing: \", path)\n"
  	"			if(path endsWithSeq(\"ioe\"),\n"
  	"				Lobby doString(decryptSourceFile(path), path)\n"
  	"				didLoadPath(path)\n"
  	"				return true\n"
  	"			)\n"
  	"			Lobby doFile(path)\n"
  	"			didLoadPath(path)\n"
  	"			return true\n"
  	"		)\n"
  	"\n"
  	"		decryptSourceFile := method(path,\n"
  	"			//writeln(\"decrypting \" .. path)\n"
  	"			return Blowfish clone setKey(key) decrypt(File with(path) contents)\n"
  	"		)\n"
  	"\n"
  	"		encryptSourceFile := method(path,\n"
  	"			//writeln(\"encrypting \" .. path)\n"
  	"			es := Blowfish clone setKey(key) encrypt(File with(path) contents)\n"
  	"			File with(path beforeSeq(\".io\") .. \".ioe\") setContents(es)\n"
  	"		)\n"
  	"\n"
  	"		didLoadPath := method(path,\n"
  	"			//writeln(\"FileImporter didLoadPath \", path)\n"
  	"			//encryptSourceFile(path)\n"
  	"			//File with(path) remove\n"
  	"			nil\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"\n"
  	"	//doc Importer FolderImporter An Importer for objects laid out as folders with files as methods.\n"
  	"	FolderImporter := Object clone do(\n"
  	"		importsFrom := \"folder\"\n"
  	"\n"
  	"		import := method(protoName,\n"
  	"			//writeln(\"FolderImporter import(\", protoName, \")\")\n"
  	"			if(hasAddon := AddonLoader hasAddonNamed(protoName),\n"
  	"				AddonLoader loadAddonNamed(protoName)\n"
  	"			)\n"
  	"			hasAddon\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	//doc Importer AddonImporter An Importer for addon modules.\n"
  	"	AddonImporter := Object clone do(\n"
  	"		importsFrom := \"dll\"\n"
  	"\n"
  	"		import := method(protoName,\n"
  	"			//writeln(\"AddonImporter import(\", protoName, \")\")\n"
  	"			if(hasAddon := AddonLoader hasAddonNamed(protoName),\n"
  	"				AddonLoader loadAddonNamed(protoName)\n"
  	"			)\n"
  	"			hasAddon\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"\n"
  	"	//doc Importer importers List of Importer objects.\n"
  	"	importers := list(FileImporter, FolderImporter, AddonImporter)\n"
  	"\n"
  	"	//doc Importer import(originalCallMessage) Imports an object or addon for the given Message.\n"
  	"	import := method(originalCall,\n"
  	"		protoName := originalCall message name\n"
  	"		//writeln(\"Importer looking for '\", protoName, \"'\")\n"
  	"\n"
  	"		if(protoName at(0) isUppercase and(importer := importers detect(import(protoName, originalCall))),\n"
  	"			if(Lobby hasSlot(protoName) not,\n"
  	"				Exception raiseFrom(originalCall, \"Importer slot '\" .. protoName .. \"' missing after \" .. importer importsFrom .. \" load\")\n"
  	"			)\n"
  	"			Lobby getSlot(protoName)\n"
  	"		,\n"
  	"			targetType := originalCall target type\n"
  	"			Exception raiseFrom(originalCall, targetType .. \" does not respond to '\" .. protoName .. \"'\")\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	//doc Importer autoImportingForward A forward method implementation placed in the Lobby when Importing is turned on.\n"
  	"	autoImportingForward := method(\n"
  	"		Importer import(call)\n"
  	"	)\n"
  	"\n"
  	"	//doc Importer turnOn Turns on the Importer. Returns self.\n"
  	"	turnOn := method(\n"
  	"		Lobby forward := self getSlot(\"autoImportingForward\")\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	//doc Importer turnOff Turns off the Importer. Returns self.\n"
  	"	turnOff := method(\n"
  	"		Lobby removeSlot(\"forward\")\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	// Auto Importer is on by default\n"
  	"	turnOn\n"
  	")\n"
  	"";

    IoState_rawOn_doCString_withLabel_(self, context, s, "Z_Importer.io");

}

